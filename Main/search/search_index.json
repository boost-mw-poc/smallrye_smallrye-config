{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"SmallRye Config # SmallRye Config is a library that provides a way to configure applications, frameworks and containers. It is used in applications servers like WildFly , Open Liberty and TomEE or frameworks like Quarkus . It can also be used completely standalone in any Java application, which makes it a very flexible library. It follows the MicroProfile Config specification to provide the initial config foundations and expands with it own concepts to cover a wide range of use cases observed in the configuration space. Use SmallRye Config in a Java application # Add the dependency to your project using your preferred build tool: Maven Gradle (Groovy) Gradle (Kotlin) JBang <dependency> <groupId> io.smallrye.config </groupId> <artifactId> smallrye-config </artifactId> <version> 3.9.1-SNAPSHOT </version> </dependency> implementation 'io.smallrye.config:smallrye-config:3.9.1-SNAPSHOT' implementation ( \"io.smallrye.config:smallrye-config:3.9.1-SNAPSHOT\" ) //DEPS io.smallrye.config:smallrye-config:3.9.1-SNAPSHOT And retrieve a SmallRyeConfig instance with: SmallRyeConfig config = ConfigProvider . getConfig (). unwrap ( SmallRyeConfig . class ); Info The SmallRyeConfig instance will be created and registered to the context class loader if no such configuration is already created and registered. Or build your own: SmallRyeConfig config = new SmallRyeConfigBuilder (). build (); Info SmallRyeConfig is the entry point to all the config capabilities provided by SmallRye Config.","title":"Home"},{"location":"#smallrye-config","text":"SmallRye Config is a library that provides a way to configure applications, frameworks and containers. It is used in applications servers like WildFly , Open Liberty and TomEE or frameworks like Quarkus . It can also be used completely standalone in any Java application, which makes it a very flexible library. It follows the MicroProfile Config specification to provide the initial config foundations and expands with it own concepts to cover a wide range of use cases observed in the configuration space.","title":"SmallRye Config"},{"location":"#use-smallrye-config-in-a-java-application","text":"Add the dependency to your project using your preferred build tool: Maven Gradle (Groovy) Gradle (Kotlin) JBang <dependency> <groupId> io.smallrye.config </groupId> <artifactId> smallrye-config </artifactId> <version> 3.9.1-SNAPSHOT </version> </dependency> implementation 'io.smallrye.config:smallrye-config:3.9.1-SNAPSHOT' implementation ( \"io.smallrye.config:smallrye-config:3.9.1-SNAPSHOT\" ) //DEPS io.smallrye.config:smallrye-config:3.9.1-SNAPSHOT And retrieve a SmallRyeConfig instance with: SmallRyeConfig config = ConfigProvider . getConfig (). unwrap ( SmallRyeConfig . class ); Info The SmallRyeConfig instance will be created and registered to the context class loader if no such configuration is already created and registered. Or build your own: SmallRyeConfig config = new SmallRyeConfigBuilder (). build (); Info SmallRyeConfig is the entry point to all the config capabilities provided by SmallRye Config.","title":"Use SmallRye Config in a Java application"},{"location":"config/config-value/","text":"Config Value # The io.smallrye.config.ConfigValue is a metadata object that holds additional information after the lookup of a configuration property. It is able to hold information of configuration property name, value, profile, the ConfigSource from where the configuration was loaded, the ordinal of the ConfigSource and a line number from where the configuration was loaded if exists.","title":"ConfigValue"},{"location":"config/config-value/#config-value","text":"The io.smallrye.config.ConfigValue is a metadata object that holds additional information after the lookup of a configuration property. It is able to hold information of configuration property name, value, profile, the ConfigSource from where the configuration was loaded, the ordinal of the ConfigSource and a line number from where the configuration was loaded if exists.","title":"Config Value"},{"location":"config/configuration/","text":"Configuration Reference # Configuration Property Type Default smallrye.config.profile The main Profile to activate. String[] smallrye.config.profile.parent The parent Profile to activate. String smallrye.config.locations Additional config locations to be loaded with the Config. The configuration supports multiple locations separated by a comma and each must represent a valid java.net.URI . URI[] smallrye.config.mapping.validate-unknown Validates that a @ConfigMapping maps every available configuration name contained in the mapping prefix. boolean false smallrye.config.secret-handlers The names of the secret handlers to be loaded. A value of all loads all available secret handlers and a value of none skips the load. String[] all smallrye.config.log.values Enable logging of configuration values lookup in DEBUG log level. boolean false","title":"Configuration Reference"},{"location":"config/configuration/#configuration-reference","text":"Configuration Property Type Default smallrye.config.profile The main Profile to activate. String[] smallrye.config.profile.parent The parent Profile to activate. String smallrye.config.locations Additional config locations to be loaded with the Config. The configuration supports multiple locations separated by a comma and each must represent a valid java.net.URI . URI[] smallrye.config.mapping.validate-unknown Validates that a @ConfigMapping maps every available configuration name contained in the mapping prefix. boolean false smallrye.config.secret-handlers The names of the secret handlers to be loaded. A value of all loads all available secret handlers and a value of none skips the load. String[] all smallrye.config.log.values Enable logging of configuration values lookup in DEBUG log level. boolean false","title":"Configuration Reference"},{"location":"config/customizer/","text":"Customizer # A SmallRyeConfigBuilderCustomizer allows to customize a SmallRyeConfigBuilder , used to create the SmallRyeConfig instance. Registration of a SmallRyeConfigBuilderCustomizer is done via the ServiceLoader mechanism by providing the implementation classes in a META-INF/services/io.smallrye.config.SmallRyeConfigBuilderCustomizer file. Alternatively, customizers may be registered via the Programmatic API in SmallRyeConfigBuilder#withCustomizers . The SmallRyeConfigBuilderCustomizer may also assign a priority by overriding the default method int priority() . Customizers are sorted by ascending priority and executed in that order, meaning that higher numeric priorities will execute last, possible overriding values set by previous customizers. CustomConfigBuilder package org.acme.config ; import io.smallrye.config.SmallRyeConfigBuilder ; import io.smallrye.config.SmallRyeConfigBuilderCustomizer ; public class CustomConfigBuilder implements SmallRyeConfigBuilderCustomizer { @Override public void configBuilder ( final SmallRyeConfigBuilder builder ) { builder . withDefaultValue ( \"my.default\" , \"1234\" ); } } And registration in: META-INF/services/io.smallrye.config.SmallRyeConfigBuilderCustomizer org.acme.config.CustomConfigBuilder The CustomConfigBuilder will be executed when creating a new SmallRyeConfig from a SmallRyeConfigBuilder : SmallRyeConfig config = new SmallRyeConfigBuilder (). build (); config . getValue ( \"my.default\" , int . class ); A look up to my.default returns the value 1234 , registered by the CustomConfigBuilder .","title":"Customizer"},{"location":"config/customizer/#customizer","text":"A SmallRyeConfigBuilderCustomizer allows to customize a SmallRyeConfigBuilder , used to create the SmallRyeConfig instance. Registration of a SmallRyeConfigBuilderCustomizer is done via the ServiceLoader mechanism by providing the implementation classes in a META-INF/services/io.smallrye.config.SmallRyeConfigBuilderCustomizer file. Alternatively, customizers may be registered via the Programmatic API in SmallRyeConfigBuilder#withCustomizers . The SmallRyeConfigBuilderCustomizer may also assign a priority by overriding the default method int priority() . Customizers are sorted by ascending priority and executed in that order, meaning that higher numeric priorities will execute last, possible overriding values set by previous customizers. CustomConfigBuilder package org.acme.config ; import io.smallrye.config.SmallRyeConfigBuilder ; import io.smallrye.config.SmallRyeConfigBuilderCustomizer ; public class CustomConfigBuilder implements SmallRyeConfigBuilderCustomizer { @Override public void configBuilder ( final SmallRyeConfigBuilder builder ) { builder . withDefaultValue ( \"my.default\" , \"1234\" ); } } And registration in: META-INF/services/io.smallrye.config.SmallRyeConfigBuilderCustomizer org.acme.config.CustomConfigBuilder The CustomConfigBuilder will be executed when creating a new SmallRyeConfig from a SmallRyeConfigBuilder : SmallRyeConfig config = new SmallRyeConfigBuilder (). build (); config . getValue ( \"my.default\" , int . class ); A look up to my.default returns the value 1234 , registered by the CustomConfigBuilder .","title":"Customizer"},{"location":"config/environment-variables/","text":"Environment Variables # Environment Variable names follow the conversion rules specified by MicroProfile Config . SmallRye Config specifies additional conversion rules: A property with double quotes foo.\"bar\".baz , replace each character that is neither alphanumeric nor _ with _ : FOO__BAR__BAZ A property with dashes foo.bar-baz , replace each character that is neither alphanumeric nor _ with _ : FOO_BAR_BAZ An indexed property foo.bar[0] or foo.bar[0].baz , replace each character that is neither alphanumeric nor _ with _ : FOO_BAR_0_ or FOO_BAR_0__BAZ . Danger Environment Variables format cannot represent the entire spectrum of common property names. The lookup of configuration values from Environment Variables will always use the dotted format name. For instance, the lookup of the Environment Variable FOO_BAR value, requires the property name foo.bar : ConfigProvider . getConfig (). getValue ( \"foo.bar\" , String . class ); When SmallRyeConfig performs the lookup on the Environment Variables Config Source, it applies the conversion rules to find the matching property name and retrieve the value. In some situations, looking up the exact property name is impossible. For instance, when SmallRye Config has to look up a configuration that is part of a Map , and the property name contains a dynamic segment (a Map key). In this case, SmallRye Config relies upon each source\u2019s list of property names. These must be converted back to their most likely dotted format for Environment Variables. By default, the underscore _ of an Environment Variable name always maps to a dot . . If the property name contains a dash or some other special character, that property name can be specified in another Config Source, with the expected dotted format. It will provide additional information to SmallRye Config to perform a two-way conversion and match the property names. Consider: .env FOO_BAR_BAZ=VALUE Will map to foo.bar.baz and value value . If foo.bar-baz is available in any source: .env FOO_BAR_BAZ=VALUE application.properties foo.bar-baz = default Will map to foo.bar-baz and value value . Note The property name in dotted format needs to exist somewhere to provide this additional information. It can be set in a low ordinal source, even without value. The Environment Variables source will override the value and map the correct configuration name.","title":"Environment Variables"},{"location":"config/environment-variables/#environment-variables","text":"Environment Variable names follow the conversion rules specified by MicroProfile Config . SmallRye Config specifies additional conversion rules: A property with double quotes foo.\"bar\".baz , replace each character that is neither alphanumeric nor _ with _ : FOO__BAR__BAZ A property with dashes foo.bar-baz , replace each character that is neither alphanumeric nor _ with _ : FOO_BAR_BAZ An indexed property foo.bar[0] or foo.bar[0].baz , replace each character that is neither alphanumeric nor _ with _ : FOO_BAR_0_ or FOO_BAR_0__BAZ . Danger Environment Variables format cannot represent the entire spectrum of common property names. The lookup of configuration values from Environment Variables will always use the dotted format name. For instance, the lookup of the Environment Variable FOO_BAR value, requires the property name foo.bar : ConfigProvider . getConfig (). getValue ( \"foo.bar\" , String . class ); When SmallRyeConfig performs the lookup on the Environment Variables Config Source, it applies the conversion rules to find the matching property name and retrieve the value. In some situations, looking up the exact property name is impossible. For instance, when SmallRye Config has to look up a configuration that is part of a Map , and the property name contains a dynamic segment (a Map key). In this case, SmallRye Config relies upon each source\u2019s list of property names. These must be converted back to their most likely dotted format for Environment Variables. By default, the underscore _ of an Environment Variable name always maps to a dot . . If the property name contains a dash or some other special character, that property name can be specified in another Config Source, with the expected dotted format. It will provide additional information to SmallRye Config to perform a two-way conversion and match the property names. Consider: .env FOO_BAR_BAZ=VALUE Will map to foo.bar.baz and value value . If foo.bar-baz is available in any source: .env FOO_BAR_BAZ=VALUE application.properties foo.bar-baz = default Will map to foo.bar-baz and value value . Note The property name in dotted format needs to exist somewhere to provide this additional information. It can be set in a low ordinal source, even without value. The Environment Variables source will override the value and map the correct configuration name.","title":"Environment Variables"},{"location":"config/expressions/","text":"Property Expressions # SmallRye Config provides property expressions expansion on configuration values. An expression string is a mix of plain strings and expression segments, which are wrapped by the sequence ${ \u2026 }. For instance, the following configuration properties file: remote.host = smallrye.io callable.url = https://${remote.host}/ The resolved value of the callable.url property is https://smallrye.io/ . Additionally, the Expression Expansion engine supports the following segments: ${expression:value} - Provides a default value after the : if the expansion doesn\u2019t find a value. ${my.prop${compose}} - Composed expressions. Inner expressions are resolved first. ${my.prop}${my.prop} - Multiple expressions. If an expression cannot be expanded and no default is supplied a NoSuchElementException is thrown. Expression expansion may be selectively disabled with io.smallrye.config.Expressions : Config config = ConfigProvider . getConfig (); String url = Expressions . withoutExpansion (() -> config . getValue ( \"callable.url\" , String . class ));","title":"Expressions"},{"location":"config/expressions/#property-expressions","text":"SmallRye Config provides property expressions expansion on configuration values. An expression string is a mix of plain strings and expression segments, which are wrapped by the sequence ${ \u2026 }. For instance, the following configuration properties file: remote.host = smallrye.io callable.url = https://${remote.host}/ The resolved value of the callable.url property is https://smallrye.io/ . Additionally, the Expression Expansion engine supports the following segments: ${expression:value} - Provides a default value after the : if the expansion doesn\u2019t find a value. ${my.prop${compose}} - Composed expressions. Inner expressions are resolved first. ${my.prop}${my.prop} - Multiple expressions. If an expression cannot be expanded and no default is supplied a NoSuchElementException is thrown. Expression expansion may be selectively disabled with io.smallrye.config.Expressions : Config config = ConfigProvider . getConfig (); String url = Expressions . withoutExpansion (() -> config . getValue ( \"callable.url\" , String . class ));","title":"Property Expressions"},{"location":"config/getting-started/","text":"Getting Started # Config Sources # By default, SmallRye Config reads configuration properties from multiple configuration sources (by descending ordinal): ( 400 ) System properties ( 300 ) Environment variables ( 295 ) .env file in the current working directory ( 260 ) application.properties in config folder, located in the current working directory ( 250 ) application.properties in the classpath ( 100 ) MicroProfile Config configuration file META-INF/microprofile-config.properties in the classpath A configuration source is handled by a ConfigSource . A ConfigSource provides configuration values from a specific place. The final configuration is the aggregation of the properties defined by all these sources. A configuration property lookup starts by the highest ordinal configuration source available and works it way down to other sources until a match is found. This means that any configuration property may override a value just by setting a different value in a higher ordinal config source. For example, a property configured using an Environment Variable overrides the value provided using the microprofile-config.properties file. System Properties # System properties can be handed to the application through the -D flag during startup. For instance, java -Dmy.prop -jar my.jar . Environment Variables # Environment variables are set directly in the host operating system. Environment variables names follow the conversion rules detailed by Environment Variables . MicroProfile Config configuration file # The MicroProfile Config configuration file META-INF/microprofile-config.properties in the classpath. It follows the standard convention for properties files. META-INF/microprofile-config.properties greeting.message = hello goodbye.message = bye Additional Config Sources # SmallRye Config provides additional extensions which cover other configuration formats and stores: YAML File System ZooKeeper HOCON It is also possible to create a Custom ConfigSource . Retrieving the Configuration # Programmatically # The org.eclipse.microprofile.config.ConfigProvider.getConfig() API allows to access the org.eclipse.microprofile.config.Config API programmatically. Config config = ConfigProvider . getConfig (); String message = config . getValue ( \"greeting.message\" , String . class ); The Config instance will be created and registered to the current context class loader if no such configuration is already created and registered. This means that subsequent calls to ConfigProvider.getConfig() will return the same Config instance if the context class loader is the same. To obtain a detached instanced, use the io.smallrye.config.SmallRyeConfigBuilder : SmallRyeConfig config = new SmallRyeConfigBuilder () . addDefaultInterceptors () . addDefaultSources () . build (); String message = config . getValue ( \"greeting.message\" , String . class ); With CDI # In a CDI environment, configuration can be injected in CDI aware beans with @Inject and the org.eclipse.microprofile.config.inject.ConfigProperty qualifier. @Inject @ConfigProperty ( name = \"greeting.message\" ) String message ; @Inject @ConfigProperty ( name = \"greeting.suffix\" , defaultValue = \"!\" ) String suffix ; @Inject @ConfigProperty ( name = \"greeting.name\" ) Optional < String > name ; @Inject SmallRyeConfig config ; If a value if not provided for this greeting.message , the application startup fails with a jakarta.enterprise.inject.spi.DeploymentException: No config value of type [class java.lang.String] exists for: greeting.message . The default value ! is injected if the configuration does not provide a value for greeting.suffix . The property greeting.name is optional - an empty Optional is injected if the configuration does not provide a value for it. Override Config # It is possible to override Config default initialization ConfigProvider.getConfig() , by extending io.smallrye.config.SmallRyeConfigFactory and registering the implementation with the ServiceLoader mechanism. Config vs SmallRyeConfig # The io.smallrye.config.SmallRyeConfig is an implementation of org.eclipse.microprofile.config.Config and provides additional APIs and helper methods not available in org.eclipse.microprofile.config.Config . To obtain an instance of io.smallrye.config.SmallRyeConfig , the original org.eclipse.microprofile.config.Config can be unwrapped: Config config = ConfigProvider . getConfig (); SmallRyeConfig smallRyeConfig = config . unwrap ( SmallRyeConfig . class ); Or if using the builder it can be obtained directly: SmallRyeConfig config = new SmallRyeConfigBuilder (). build (); A few notable APIs provided by io.smallrye.config.SmallRyeConfig allow to: Retrive multiple values into a specified Collection Retrive Indexed Values Retrive Config Mappings instances Retrieve the raw value of a configuration Check if a property is present Retrieve a Converter Convert values Converters # The ConfigSource retrieves a configuration value as a String . Other data types require a conversion using the org.eclipse.microprofile.config.spi.Converter API. Most of the common Converter types are provided by default: boolean and java.lang.Boolean ; the values \u201ctrue\u201d, \u201c1\u201d, \u201cYES\u201d, \u201cY\u201d \u201cON\u201d represent true . Any other value will be interpreted as false byte and java.lang.Byte short and java.lang.Short int , java.lang.Integer , and java.util.OptionalInt long , java.lang.Long , and java.util.OptionalLong float and java.lang.Float ; a dot \u2018.\u2019 is used to separate the fractional digits double , java.lang.Double , and java.util.OptionalDouble ; a dot \u2018.\u2019 is used to separate the fractional digits char and java.lang.Character java.lang.Class based on the result of Class.forName java.net.InetAddress java.util.UUID java.util.Currency java.util.regex.Pattern java.nio.file.Path Any class with declared static methods of , valueOf or parse that take a String or a CharSequence Any class with declared constructors that takes a String or a CharSequence All default converters have a priority of 1 .","title":"Getting Started"},{"location":"config/getting-started/#getting-started","text":"","title":"Getting Started"},{"location":"config/getting-started/#config-sources","text":"By default, SmallRye Config reads configuration properties from multiple configuration sources (by descending ordinal): ( 400 ) System properties ( 300 ) Environment variables ( 295 ) .env file in the current working directory ( 260 ) application.properties in config folder, located in the current working directory ( 250 ) application.properties in the classpath ( 100 ) MicroProfile Config configuration file META-INF/microprofile-config.properties in the classpath A configuration source is handled by a ConfigSource . A ConfigSource provides configuration values from a specific place. The final configuration is the aggregation of the properties defined by all these sources. A configuration property lookup starts by the highest ordinal configuration source available and works it way down to other sources until a match is found. This means that any configuration property may override a value just by setting a different value in a higher ordinal config source. For example, a property configured using an Environment Variable overrides the value provided using the microprofile-config.properties file.","title":"Config Sources"},{"location":"config/getting-started/#system-properties","text":"System properties can be handed to the application through the -D flag during startup. For instance, java -Dmy.prop -jar my.jar .","title":"System Properties"},{"location":"config/getting-started/#environment-variables","text":"Environment variables are set directly in the host operating system. Environment variables names follow the conversion rules detailed by Environment Variables .","title":"Environment Variables"},{"location":"config/getting-started/#microprofile-config-configuration-file","text":"The MicroProfile Config configuration file META-INF/microprofile-config.properties in the classpath. It follows the standard convention for properties files. META-INF/microprofile-config.properties greeting.message = hello goodbye.message = bye","title":"MicroProfile Config configuration file"},{"location":"config/getting-started/#additional-config-sources","text":"SmallRye Config provides additional extensions which cover other configuration formats and stores: YAML File System ZooKeeper HOCON It is also possible to create a Custom ConfigSource .","title":"Additional Config Sources"},{"location":"config/getting-started/#retrieving-the-configuration","text":"","title":"Retrieving the Configuration"},{"location":"config/getting-started/#programmatically","text":"The org.eclipse.microprofile.config.ConfigProvider.getConfig() API allows to access the org.eclipse.microprofile.config.Config API programmatically. Config config = ConfigProvider . getConfig (); String message = config . getValue ( \"greeting.message\" , String . class ); The Config instance will be created and registered to the current context class loader if no such configuration is already created and registered. This means that subsequent calls to ConfigProvider.getConfig() will return the same Config instance if the context class loader is the same. To obtain a detached instanced, use the io.smallrye.config.SmallRyeConfigBuilder : SmallRyeConfig config = new SmallRyeConfigBuilder () . addDefaultInterceptors () . addDefaultSources () . build (); String message = config . getValue ( \"greeting.message\" , String . class );","title":"Programmatically"},{"location":"config/getting-started/#with-cdi","text":"In a CDI environment, configuration can be injected in CDI aware beans with @Inject and the org.eclipse.microprofile.config.inject.ConfigProperty qualifier. @Inject @ConfigProperty ( name = \"greeting.message\" ) String message ; @Inject @ConfigProperty ( name = \"greeting.suffix\" , defaultValue = \"!\" ) String suffix ; @Inject @ConfigProperty ( name = \"greeting.name\" ) Optional < String > name ; @Inject SmallRyeConfig config ; If a value if not provided for this greeting.message , the application startup fails with a jakarta.enterprise.inject.spi.DeploymentException: No config value of type [class java.lang.String] exists for: greeting.message . The default value ! is injected if the configuration does not provide a value for greeting.suffix . The property greeting.name is optional - an empty Optional is injected if the configuration does not provide a value for it.","title":"With CDI"},{"location":"config/getting-started/#override-config","text":"It is possible to override Config default initialization ConfigProvider.getConfig() , by extending io.smallrye.config.SmallRyeConfigFactory and registering the implementation with the ServiceLoader mechanism.","title":"Override Config"},{"location":"config/getting-started/#config-vs-smallryeconfig","text":"The io.smallrye.config.SmallRyeConfig is an implementation of org.eclipse.microprofile.config.Config and provides additional APIs and helper methods not available in org.eclipse.microprofile.config.Config . To obtain an instance of io.smallrye.config.SmallRyeConfig , the original org.eclipse.microprofile.config.Config can be unwrapped: Config config = ConfigProvider . getConfig (); SmallRyeConfig smallRyeConfig = config . unwrap ( SmallRyeConfig . class ); Or if using the builder it can be obtained directly: SmallRyeConfig config = new SmallRyeConfigBuilder (). build (); A few notable APIs provided by io.smallrye.config.SmallRyeConfig allow to: Retrive multiple values into a specified Collection Retrive Indexed Values Retrive Config Mappings instances Retrieve the raw value of a configuration Check if a property is present Retrieve a Converter Convert values","title":"Config vs SmallRyeConfig"},{"location":"config/getting-started/#converters","text":"The ConfigSource retrieves a configuration value as a String . Other data types require a conversion using the org.eclipse.microprofile.config.spi.Converter API. Most of the common Converter types are provided by default: boolean and java.lang.Boolean ; the values \u201ctrue\u201d, \u201c1\u201d, \u201cYES\u201d, \u201cY\u201d \u201cON\u201d represent true . Any other value will be interpreted as false byte and java.lang.Byte short and java.lang.Short int , java.lang.Integer , and java.util.OptionalInt long , java.lang.Long , and java.util.OptionalLong float and java.lang.Float ; a dot \u2018.\u2019 is used to separate the fractional digits double , java.lang.Double , and java.util.OptionalDouble ; a dot \u2018.\u2019 is used to separate the fractional digits char and java.lang.Character java.lang.Class based on the result of Class.forName java.net.InetAddress java.util.UUID java.util.Currency java.util.regex.Pattern java.nio.file.Path Any class with declared static methods of , valueOf or parse that take a String or a CharSequence Any class with declared constructors that takes a String or a CharSequence All default converters have a priority of 1 .","title":"Converters"},{"location":"config/indexed-properties/","text":"Indexed Properties # In MicroProfile Config , a config value with unescaped commas may be converted to Collection . It works for simple cases, but it becomes cumbersome and limited for more advanced use cases. Indexed Properties provide a way to use indexes in config property names to map specific elements in a Collection type. Since the indexed element is part of the property name, it can also map complex object types. Consider: # MicroProfile Config - Collection Values my.collection = dog,cat,turtle # SmallRye Config - Indexed Property my.indexed.collection[0] = dog my.indexed.collection[1] = cat my.indexed.collection[2] = turtle The indexed property syntax uses the property name and square brackets with an index in between. A call to Config#getValues(\"my.collection\", String.class) , will automatically create and convert a List<String> that contains the values dog , cat and turtle . A call to Config#getValues(\"my.indexed.collection\", String.class) returns the exact same result. For compatibility reasons, if SmallRye Config finds the same property name in their indexed and unindexed format, the unindexed value has priority. The indexed property is sorted by its index before being added to the target Collection . Any gaps in the indexes do not resolve to the target Collection , which means that the Collection result will store all values without empty elements.","title":"Indexed Properties"},{"location":"config/indexed-properties/#indexed-properties","text":"In MicroProfile Config , a config value with unescaped commas may be converted to Collection . It works for simple cases, but it becomes cumbersome and limited for more advanced use cases. Indexed Properties provide a way to use indexes in config property names to map specific elements in a Collection type. Since the indexed element is part of the property name, it can also map complex object types. Consider: # MicroProfile Config - Collection Values my.collection = dog,cat,turtle # SmallRye Config - Indexed Property my.indexed.collection[0] = dog my.indexed.collection[1] = cat my.indexed.collection[2] = turtle The indexed property syntax uses the property name and square brackets with an index in between. A call to Config#getValues(\"my.collection\", String.class) , will automatically create and convert a List<String> that contains the values dog , cat and turtle . A call to Config#getValues(\"my.indexed.collection\", String.class) returns the exact same result. For compatibility reasons, if SmallRye Config finds the same property name in their indexed and unindexed format, the unindexed value has priority. The indexed property is sorted by its index before being added to the target Collection . Any gaps in the indexes do not resolve to the target Collection , which means that the Collection result will store all values without empty elements.","title":"Indexed Properties"},{"location":"config/map-support/","text":"Map Support # SmallRye Config allows injecting multiple configuration parameters as a Map . The configuration value syntax is represented by property.name.map-key=value Consider: server.reasons.200 = OK server.reasons.201 = Created The previous configuration could be injected directly in a CDI Bean: With @ConfigProperty @ApplicationScoped public class ConfigBean { @Inject @ConfigProperty ( name = \"server.reasons\" ) Map < Integer , String > reasons ; } With @ConfigProperties @ConfigProperties ( prefix = \"server\" ) public class Config { Map < Integer , String > reasons ; } The Map will contains the keys 200 and 201 , which map to the values OK and Created . Note Only the direct sub properties will be converted into a Map and injected into the target bean, the rest will be ignored. In other words, in the previous example, a property whose name is reasons.200.a would be ignored as not considered as a direct sub property. Note The property will be considered as missing if no direct sub properties could be found. It is also possible to retrieve the Map programmatically by calling the methods SmallRyeConfig#getValues(\"server.reasons\", Integer.class, String.class) or SmallRyeConfig#getOptionalValues(\"server.reasons\", Integer.class, String.class) .","title":"Map Support"},{"location":"config/map-support/#map-support","text":"SmallRye Config allows injecting multiple configuration parameters as a Map . The configuration value syntax is represented by property.name.map-key=value Consider: server.reasons.200 = OK server.reasons.201 = Created The previous configuration could be injected directly in a CDI Bean: With @ConfigProperty @ApplicationScoped public class ConfigBean { @Inject @ConfigProperty ( name = \"server.reasons\" ) Map < Integer , String > reasons ; } With @ConfigProperties @ConfigProperties ( prefix = \"server\" ) public class Config { Map < Integer , String > reasons ; } The Map will contains the keys 200 and 201 , which map to the values OK and Created . Note Only the direct sub properties will be converted into a Map and injected into the target bean, the rest will be ignored. In other words, in the previous example, a property whose name is reasons.200.a would be ignored as not considered as a direct sub property. Note The property will be considered as missing if no direct sub properties could be found. It is also possible to retrieve the Map programmatically by calling the methods SmallRyeConfig#getValues(\"server.reasons\", Integer.class, String.class) or SmallRyeConfig#getOptionalValues(\"server.reasons\", Integer.class, String.class) .","title":"Map Support"},{"location":"config/mappings/","text":"Mappings # With SmallRye Config Mappings, it is possible to group multiple configuration properties in a single interface that share the same prefix (or namespace). It supports the following set of features: Automatic conversion of the configuration type, including List , Set , Map , Optional and primitive types. Nested Config Mapping groups. Configuration Properties Naming Strategies Integration with Bean Validation A Config Mapping requires an interface with minimal metadata configuration annotated with io.smallrye.config.ConfigMapping : @ConfigMapping ( prefix = \"server\" ) interface Server { String host (); int port (); } The Server interface is able to map configurations with the name server.host into the Server#host() method and server.port into Server#port() method. The configuration property name to lookup is built from the prefix, and the method name with . (dot) as the separator. Warning If a mapping fails to match a configuration property a NoSuchElementException is thrown, unless the mapped element is an Optional . Registration # Registration of Config Mappings is automatic in CDI aware environments with the @ConfigMapping annotation. In non-CDI environments, the Config Mapping can be registered via SmallRyeConfigBuilder#withMapping . In this case, the @ConfigMapping is completely optional (but recommendeded to set the prefix). SmallRyeConfig config = new SmallRyeConfigBuilder () . withMapping ( Server . class ) . build (); Retrieval # A config mapping interface can be injected into any CDI aware bean: @ApplicationScoped class BusinessBean { @Inject Server server ; public void businessMethod () { String host = server . host (); } } In non-CDI environments, use the API io.smallrye.config.SmallRyeConfig#getConfigMapping to retrieve the config mapping instance: SmallRyeConfig config = ConfigProvider . getConfig (). unwrap ( SmallRyeConfig . class ); Server server = config . getConfigMapping ( Server . class ); Info Config Mapping instances are cached. They are populated when the Config instance is initialized and their values are not updated on Config Source changes. For a Config Mapping to be valid, it needs to match every configuration property name contained in the Config under the specified prefix set in @ConfigMapping . This prevents unknown configuration properties in the Config . This behaviour can be disabled with the configuration smallrye.config.mapping.validate-unknown=false . Defaults # The io.smallrye.config.WithDefault annotation allows to set a default property value into a mapping (and prevent errors if the configuration value is not available in any ConfigSource ). public interface Defaults { @WithDefault ( \"foo\" ) String foo (); @WithDefault ( \"bar\" ) String bar (); } No configuration properties are required. The Defaults#foo() will return the value foo and Defaults#bar() will return the value bar . Nested Groups # A nested mapping provides a way to map sub-groups of configuration properties. @ConfigMapping ( prefix = \"server\" ) public interface Server { String host (); int port (); Log log (); interface Log { boolean enabled (); String suffix (); boolean rotate (); } } server.host = localhost server.port = 8080 server.log.enabled = true server.log.suffix = .log server.log.rotate = false The method name of a mapping group acts as a sub-prefix in the property name. In this case the matching property to Server.Log#enabled is server.log.enabled . Overriding property names # @WithName # If a method name and a property name do not match, the io.smallrye.config.WithName annotation can override the method name mapping and use the name supplied in the annotation. @ConfigMapping ( prefix = \"server\" ) interface Server { @WithName ( \"name\" ) String host (); int port (); } server.name = localhost server.port = 8080 @WithParentName # The io.smallrye.config.WithParentName annotation allows configurations mappings to inherit its parent container name, simplifying the configuration property name required to match the mapping. @ConfigMapping ( prefix = \"server\" ) interface Server { @WithParentName ServerHostAndPort hostAndPort (); @WithParentName ServerInfo info (); } interface ServerHostAndPort { String host (); int port (); } interface ServerInfo { String name (); } server.host = localhost server.port = 8080 server.name = konoha Without the @WithParentName the method ServerInfo#name maps the configuration property server.info.name . With @WithParentName , the Server#info mapping will inherit the parent name from Server and ServerInfo#name maps to the property server.name instead. NamingStrategy # Method names in camelCase map to kebab-case configuration property names by default. @ConfigMapping ( prefix = \"server\" ) interface Server { String theHost (); int thePort (); } server.the-host = localhost server.the-port = 8080 The mapping strategy can be adjusted by setting namingStrategy value in the @ConfigMapping annotation. @ConfigMapping ( prefix = \"server\" , namingStrategy = ConfigMapping . NamingStrategy . VERBATIM ) public interface ServerVerbatimNamingStrategy { String theHost (); int thePort (); } server.theHost = localhost server.thePort = 8080 The @ConfigMapping annotation support the following naming stategies: KEBAB_CASE - The method name is derived by replacing case changes with a dash to map the configuration property. VERBATIM - The method name is used as is to map the configuration property. SNAKE_CASE - The method name is derived by replacing case changes with an underscore to map the configuration property. Conversion # A config mapping interface support automatic conversions of all types available for conversion in Config . @ConfigMapping public interface SomeTypes { @WithName ( \"int\" ) int intPrimitive (); @WithName ( \"int\" ) Integer intWrapper (); @WithName ( \"long\" ) long longPrimitive (); @WithName ( \"long\" ) Long longWrapper (); @WithName ( \"float\" ) float floatPrimitive (); @WithName ( \"float\" ) Float floatWrapper (); @WithName ( \"double\" ) double doublePrimitive (); @WithName ( \"double\" ) Double doubleWrapper (); @WithName ( \"char\" ) char charPrimitive (); @WithName ( \"char\" ) Character charWrapper (); @WithName ( \"boolean\" ) boolean booleanPrimitive (); @WithName ( \"boolean\" ) Boolean booleanWrapper (); } int = 9 long = 9999999999 float = 99.9 double = 99.99 char = c boolean = true This is also valid for Optional and friends. @ConfigMapping public interface Optionals { Optional < Server > server (); Optional < String > optional (); @WithName ( \"optional.int\" ) OptionalInt optionalInt (); interface Server { String host (); int port (); } } In this case, the mapping won\u2019t fail if the configuraton properties values are missing. @WithConverter # The io.smallrye.config.WithConverter annotation provides a way to set a specific Converter in a mapping. @ConfigMapping public interface Converters { @WithConverter ( FooBarConverter . class ) String foo (); } public static class FooBarConverter implements Converter < String > { @Override public String convert ( final String value ) { return \"bar\" ; } } foo = foo A call to Converters.foo() results in the value bar . Collections # A config mapping is also able to map the collections types List and Set : @ConfigMapping ( prefix = \"server\" ) public interface ServerCollections { Set < Environment > environments (); interface Environment { String name (); List < App > apps (); interface App { String name (); List < String > services (); Optional < List < String >> databases (); } } } server.environments[0].name = dev server.environments[0].apps[0].name = rest server.environments[0].apps[0].services = bookstore,registration server.environments[0].apps[0].databases = pg,h2 server.environments[0].apps[1].name = batch server.environments[0].apps[1].services = stock,warehouse The List and Set mappings can use Indexed Properties to map configuration values in mapping groups. Maps # A config mapping is also able to map a Map : @ConfigMapping ( prefix = \"server\" ) public interface Server { String host (); int port (); Map < String , String > form (); Map < String , List < Alias >> aliases (); interface Alias { String name (); } } server.host = localhost server.port = 8080 server.form.index = index.html server.form.login.page = login.html server.form.error.page = error.html server.aliases.localhost[0].name = prod server.aliases.localhost[1].name = 127.0.0.1 server.aliases. \\\" io.smallrye \\\" [0].name = smallrye The configuration property name needs to specify an additional segment to act as the map key. The server.form matches the Server#form Map and the segments index , login.page and error.page represent the Map keys. For collection types, the key requires the indexed format. The configuration name server.aliases.localhost[0].name maps to the Map<String, List<Alias>> aliases() member, where localhost is the Map key, [0] is the index of the List<Alias> collection where the Alias element will be stored, containing the name prod . Info They Map key part in the configuration property name may require quotes to delimit the key. @WithUnnamedKey # The io.smallrye.config.WithUnnamedKey annotation allows to omit a single map key in the configuration path: @ConfigMapping ( prefix = \"server\" ) public interface Server { @WithUnnamedKey ( \"localhost\" ) Map < String , Alias > aliases (); interface Alias { String name (); } } server.aliases.name = localhost server.aliases.prod.name = prod The sever.aliases.name is an unnamed Map property, because it does not contain the Map key to populate the Map entry. Due to @WithUnnamedKey(\"localhost\") the Map key is not required in the configuration path. The key used to look up the Map entry is given by io.smallrye.config.WithUnnamedKey#value : Server server = config . getConfigMapping ( Server . class ); Map < String , Alias > localhost = server . aliases . get ( \"localhost\" ); Warning If the unnamed key (in this case localhost ) is explicitly set in a property name, the mapping will throw an error. @WithDefaults # The io.smallrye.config.WithDefaults is a marker annotation to use only in a Map to return the default value for the value element on any key lookup: @ConfigMapping ( prefix = \"server\" ) public interface Server { @WithDefaults Map < String , Alias > aliases (); interface Alias { @WithDefault ( \"localhost\" ) String name (); } } server.aliases.prod.name = prod A look up to the aliases Map with the key localhost , any or any other key, returns a Alias instance, where Alias.name is localhost , because that is the default value. A look up to prod returns a Alias instance, where Alias.name is prod because the property is defined in the configuration as server.aliases.prod.name=prod . Server server = config . getConfigMapping ( Server . class ); Map < String , Alias > localhost = server . aliases . get ( \"localhost\" ); Map < String , Alias > any = server . aliases . get ( \"any\" ); Map < String , Alias > any = server . aliases . get ( \"prod\" ); ToString # If the config mapping contains a toString method declaration, the config mapping instance will include a proper implementation of the toString method. Caution Do not include a toString declaration in a config mapping with sensitive information. Validation # A config mapping may combine annotations from Bean Validation to validate configuration properties values. @ConfigMapping ( prefix = \"server\" ) interface Server { @Size ( min = 2 , max = 20 ) String host (); @Max ( 10000 ) int port (); } The application startup fails with a io.smallrye.config.ConfigValidationException if the configuration properties values do not follow the contraints defined in Server . Info For validation to work, the smallrye-config-validator dependency is required in the classpath.","title":"Mappings"},{"location":"config/mappings/#mappings","text":"With SmallRye Config Mappings, it is possible to group multiple configuration properties in a single interface that share the same prefix (or namespace). It supports the following set of features: Automatic conversion of the configuration type, including List , Set , Map , Optional and primitive types. Nested Config Mapping groups. Configuration Properties Naming Strategies Integration with Bean Validation A Config Mapping requires an interface with minimal metadata configuration annotated with io.smallrye.config.ConfigMapping : @ConfigMapping ( prefix = \"server\" ) interface Server { String host (); int port (); } The Server interface is able to map configurations with the name server.host into the Server#host() method and server.port into Server#port() method. The configuration property name to lookup is built from the prefix, and the method name with . (dot) as the separator. Warning If a mapping fails to match a configuration property a NoSuchElementException is thrown, unless the mapped element is an Optional .","title":"Mappings"},{"location":"config/mappings/#registration","text":"Registration of Config Mappings is automatic in CDI aware environments with the @ConfigMapping annotation. In non-CDI environments, the Config Mapping can be registered via SmallRyeConfigBuilder#withMapping . In this case, the @ConfigMapping is completely optional (but recommendeded to set the prefix). SmallRyeConfig config = new SmallRyeConfigBuilder () . withMapping ( Server . class ) . build ();","title":"Registration"},{"location":"config/mappings/#retrieval","text":"A config mapping interface can be injected into any CDI aware bean: @ApplicationScoped class BusinessBean { @Inject Server server ; public void businessMethod () { String host = server . host (); } } In non-CDI environments, use the API io.smallrye.config.SmallRyeConfig#getConfigMapping to retrieve the config mapping instance: SmallRyeConfig config = ConfigProvider . getConfig (). unwrap ( SmallRyeConfig . class ); Server server = config . getConfigMapping ( Server . class ); Info Config Mapping instances are cached. They are populated when the Config instance is initialized and their values are not updated on Config Source changes. For a Config Mapping to be valid, it needs to match every configuration property name contained in the Config under the specified prefix set in @ConfigMapping . This prevents unknown configuration properties in the Config . This behaviour can be disabled with the configuration smallrye.config.mapping.validate-unknown=false .","title":"Retrieval"},{"location":"config/mappings/#defaults","text":"The io.smallrye.config.WithDefault annotation allows to set a default property value into a mapping (and prevent errors if the configuration value is not available in any ConfigSource ). public interface Defaults { @WithDefault ( \"foo\" ) String foo (); @WithDefault ( \"bar\" ) String bar (); } No configuration properties are required. The Defaults#foo() will return the value foo and Defaults#bar() will return the value bar .","title":"Defaults"},{"location":"config/mappings/#nested-groups","text":"A nested mapping provides a way to map sub-groups of configuration properties. @ConfigMapping ( prefix = \"server\" ) public interface Server { String host (); int port (); Log log (); interface Log { boolean enabled (); String suffix (); boolean rotate (); } } server.host = localhost server.port = 8080 server.log.enabled = true server.log.suffix = .log server.log.rotate = false The method name of a mapping group acts as a sub-prefix in the property name. In this case the matching property to Server.Log#enabled is server.log.enabled .","title":"Nested Groups"},{"location":"config/mappings/#overriding-property-names","text":"","title":"Overriding property names"},{"location":"config/mappings/#withname","text":"If a method name and a property name do not match, the io.smallrye.config.WithName annotation can override the method name mapping and use the name supplied in the annotation. @ConfigMapping ( prefix = \"server\" ) interface Server { @WithName ( \"name\" ) String host (); int port (); } server.name = localhost server.port = 8080","title":"@WithName"},{"location":"config/mappings/#withparentname","text":"The io.smallrye.config.WithParentName annotation allows configurations mappings to inherit its parent container name, simplifying the configuration property name required to match the mapping. @ConfigMapping ( prefix = \"server\" ) interface Server { @WithParentName ServerHostAndPort hostAndPort (); @WithParentName ServerInfo info (); } interface ServerHostAndPort { String host (); int port (); } interface ServerInfo { String name (); } server.host = localhost server.port = 8080 server.name = konoha Without the @WithParentName the method ServerInfo#name maps the configuration property server.info.name . With @WithParentName , the Server#info mapping will inherit the parent name from Server and ServerInfo#name maps to the property server.name instead.","title":"@WithParentName"},{"location":"config/mappings/#namingstrategy","text":"Method names in camelCase map to kebab-case configuration property names by default. @ConfigMapping ( prefix = \"server\" ) interface Server { String theHost (); int thePort (); } server.the-host = localhost server.the-port = 8080 The mapping strategy can be adjusted by setting namingStrategy value in the @ConfigMapping annotation. @ConfigMapping ( prefix = \"server\" , namingStrategy = ConfigMapping . NamingStrategy . VERBATIM ) public interface ServerVerbatimNamingStrategy { String theHost (); int thePort (); } server.theHost = localhost server.thePort = 8080 The @ConfigMapping annotation support the following naming stategies: KEBAB_CASE - The method name is derived by replacing case changes with a dash to map the configuration property. VERBATIM - The method name is used as is to map the configuration property. SNAKE_CASE - The method name is derived by replacing case changes with an underscore to map the configuration property.","title":"NamingStrategy"},{"location":"config/mappings/#conversion","text":"A config mapping interface support automatic conversions of all types available for conversion in Config . @ConfigMapping public interface SomeTypes { @WithName ( \"int\" ) int intPrimitive (); @WithName ( \"int\" ) Integer intWrapper (); @WithName ( \"long\" ) long longPrimitive (); @WithName ( \"long\" ) Long longWrapper (); @WithName ( \"float\" ) float floatPrimitive (); @WithName ( \"float\" ) Float floatWrapper (); @WithName ( \"double\" ) double doublePrimitive (); @WithName ( \"double\" ) Double doubleWrapper (); @WithName ( \"char\" ) char charPrimitive (); @WithName ( \"char\" ) Character charWrapper (); @WithName ( \"boolean\" ) boolean booleanPrimitive (); @WithName ( \"boolean\" ) Boolean booleanWrapper (); } int = 9 long = 9999999999 float = 99.9 double = 99.99 char = c boolean = true This is also valid for Optional and friends. @ConfigMapping public interface Optionals { Optional < Server > server (); Optional < String > optional (); @WithName ( \"optional.int\" ) OptionalInt optionalInt (); interface Server { String host (); int port (); } } In this case, the mapping won\u2019t fail if the configuraton properties values are missing.","title":"Conversion"},{"location":"config/mappings/#withconverter","text":"The io.smallrye.config.WithConverter annotation provides a way to set a specific Converter in a mapping. @ConfigMapping public interface Converters { @WithConverter ( FooBarConverter . class ) String foo (); } public static class FooBarConverter implements Converter < String > { @Override public String convert ( final String value ) { return \"bar\" ; } } foo = foo A call to Converters.foo() results in the value bar .","title":"@WithConverter"},{"location":"config/mappings/#collections","text":"A config mapping is also able to map the collections types List and Set : @ConfigMapping ( prefix = \"server\" ) public interface ServerCollections { Set < Environment > environments (); interface Environment { String name (); List < App > apps (); interface App { String name (); List < String > services (); Optional < List < String >> databases (); } } } server.environments[0].name = dev server.environments[0].apps[0].name = rest server.environments[0].apps[0].services = bookstore,registration server.environments[0].apps[0].databases = pg,h2 server.environments[0].apps[1].name = batch server.environments[0].apps[1].services = stock,warehouse The List and Set mappings can use Indexed Properties to map configuration values in mapping groups.","title":"Collections"},{"location":"config/mappings/#maps","text":"A config mapping is also able to map a Map : @ConfigMapping ( prefix = \"server\" ) public interface Server { String host (); int port (); Map < String , String > form (); Map < String , List < Alias >> aliases (); interface Alias { String name (); } } server.host = localhost server.port = 8080 server.form.index = index.html server.form.login.page = login.html server.form.error.page = error.html server.aliases.localhost[0].name = prod server.aliases.localhost[1].name = 127.0.0.1 server.aliases. \\\" io.smallrye \\\" [0].name = smallrye The configuration property name needs to specify an additional segment to act as the map key. The server.form matches the Server#form Map and the segments index , login.page and error.page represent the Map keys. For collection types, the key requires the indexed format. The configuration name server.aliases.localhost[0].name maps to the Map<String, List<Alias>> aliases() member, where localhost is the Map key, [0] is the index of the List<Alias> collection where the Alias element will be stored, containing the name prod . Info They Map key part in the configuration property name may require quotes to delimit the key.","title":"Maps"},{"location":"config/mappings/#withunnamedkey","text":"The io.smallrye.config.WithUnnamedKey annotation allows to omit a single map key in the configuration path: @ConfigMapping ( prefix = \"server\" ) public interface Server { @WithUnnamedKey ( \"localhost\" ) Map < String , Alias > aliases (); interface Alias { String name (); } } server.aliases.name = localhost server.aliases.prod.name = prod The sever.aliases.name is an unnamed Map property, because it does not contain the Map key to populate the Map entry. Due to @WithUnnamedKey(\"localhost\") the Map key is not required in the configuration path. The key used to look up the Map entry is given by io.smallrye.config.WithUnnamedKey#value : Server server = config . getConfigMapping ( Server . class ); Map < String , Alias > localhost = server . aliases . get ( \"localhost\" ); Warning If the unnamed key (in this case localhost ) is explicitly set in a property name, the mapping will throw an error.","title":"@WithUnnamedKey"},{"location":"config/mappings/#withdefaults","text":"The io.smallrye.config.WithDefaults is a marker annotation to use only in a Map to return the default value for the value element on any key lookup: @ConfigMapping ( prefix = \"server\" ) public interface Server { @WithDefaults Map < String , Alias > aliases (); interface Alias { @WithDefault ( \"localhost\" ) String name (); } } server.aliases.prod.name = prod A look up to the aliases Map with the key localhost , any or any other key, returns a Alias instance, where Alias.name is localhost , because that is the default value. A look up to prod returns a Alias instance, where Alias.name is prod because the property is defined in the configuration as server.aliases.prod.name=prod . Server server = config . getConfigMapping ( Server . class ); Map < String , Alias > localhost = server . aliases . get ( \"localhost\" ); Map < String , Alias > any = server . aliases . get ( \"any\" ); Map < String , Alias > any = server . aliases . get ( \"prod\" );","title":"@WithDefaults"},{"location":"config/mappings/#tostring","text":"If the config mapping contains a toString method declaration, the config mapping instance will include a proper implementation of the toString method. Caution Do not include a toString declaration in a config mapping with sensitive information.","title":"ToString"},{"location":"config/mappings/#validation","text":"A config mapping may combine annotations from Bean Validation to validate configuration properties values. @ConfigMapping ( prefix = \"server\" ) interface Server { @Size ( min = 2 , max = 20 ) String host (); @Max ( 10000 ) int port (); } The application startup fails with a io.smallrye.config.ConfigValidationException if the configuration properties values do not follow the contraints defined in Server . Info For validation to work, the smallrye-config-validator dependency is required in the classpath.","title":"Validation"},{"location":"config/profiles/","text":"Profiles # Applications often require different configurations depending on the target environment. For example, the local development environment may be different from the production environment. Profiles allow for multiple configurations in the same file or separate files and select between them via a profile name. Profile aware properties # To be able to set properties with the same name, each property needs to be prefixed with a percentage sign % followed by the profile name and a dot . in the syntax %{profile-name}.config.name : META-INF/microprofile-config.properties http.port = 8080 %dev.http.port = 8181 To activate the profile dev , the configuration smallrye.config.profile=dev has to be set into any valid ConfigSource . Any lookup to the http.port property name will first search by the active profile name %dev.http.port and then fallback to http.port if no value is present. In this case a lookup to the property http.port with the dev profile active, yields the value 8181 . Attention The profile must be set in one of the primary sources (system properties, environment variables, application.properties , or any other source that does not require configuration) to determine the proper configuration. Profile aware files # Properties for a specific profile may reside in a microprofile-config-{profile}.properties named file. The previous example can be expressed as: META-INF/microprofile-config.properties http.port = 8080 META-INF/microprofile-config-dev.properties http.port = 8181 In this style, the property names in the profile aware file do not need to be prefixed with the profile name. Note Properties in the profile aware file have priority over profile aware properties defined in the main file. Attention Do not use Profile aware files to set smallrye.config.profile . This will not work because the the profile is required in advance to load the profile aware files. Priority # Profile lookups are only valid if the ConfigSource has a higher ordinal than a lookup to the regular configuration name. Consider: main.properties config_ordinal = 1000 http.port = 8080 profile.properties config_ordinal = 100 %dev.http.port = 8181 Even with the profile dev active, the lookup value for my.prop is 1234 . This prevents lower ordinal sources to set a profile property value that cannot be overridden unless the profile property is also overridden. Multiple Profiles # Multiple Profiles may be active at the same time. The configuration smallrye.config.profile accepts a comma-separated list of profile names: smallrye.config.profile=common,dev . Both common and dev are separate profiles. When multiple profiles are active, the rules for profile configuration are the same. If two profiles define the same configuration, then the last listed profile has priority. Consider: smallrye.config.profile = common,dev my.prop = 1234 %common.my.prop = 1234 %dev.my.prop = 5678 %common.commom.prop = common %dev.dev.prop = dev %test.test.prop = test Then common.prop value is common dev.prop value is dev my.prop value is 5678 test.prop does not have a value It is also possible to define multiple profile properties, with a comma-separated list of profile names: %prod,dev.my.prop = 1234 The property name common.prop is active in both dev and prod profile. If the same property name exists in multiple profile properties then, the property name with the most specific profile wins: smallrye.config.profile = dev %prod,dev.my.prop = 1234 %dev.my.prop = 5678 Then my.prop value is 5678 . Parent Profile # A Parent Profile adds multiple levels of hierarchy to the current profile. The configuration smallrye.config.profile.parent also acccepts a comma-separated list of profile names. When the Parent Profile is active, if a property cannot be found in the current active Profile, the config lookup fallbacks to the Parent Profile. Consider: smallrye.config.profile = dev smallrye.config.profile.parent = common my.prop = 1234 %common.my.prop = 0 %dev.my.prop = 5678 %common.commom.prop = common %dev.dev.prop = dev %test.test.prop = test Then common.prop value is common dev.prop value is dev my.prop value is 0 test.prop does not have a value Attention Do not use Profile aware files to set smallrye.config.profile.parent`. This will not work because the the profile is required in advance to load the profile aware files. Multi-level Hierarchy # The Parent Profile also supports multiple levels of hierarchies: smallrye.config.profile = child %child.smallrye.config.profile.parent = parent %parent.smallrye.config.profile.parent = grandparent %grandparent.smallrye.config.profile.parent = greatgrandparent %greatgrandparent.smallrye.config.profile.parent = end Will load the following profiles in order: child , parent , grandparent , greatgrandparent , end","title":"Profiles"},{"location":"config/profiles/#profiles","text":"Applications often require different configurations depending on the target environment. For example, the local development environment may be different from the production environment. Profiles allow for multiple configurations in the same file or separate files and select between them via a profile name.","title":"Profiles"},{"location":"config/profiles/#profile-aware-properties","text":"To be able to set properties with the same name, each property needs to be prefixed with a percentage sign % followed by the profile name and a dot . in the syntax %{profile-name}.config.name : META-INF/microprofile-config.properties http.port = 8080 %dev.http.port = 8181 To activate the profile dev , the configuration smallrye.config.profile=dev has to be set into any valid ConfigSource . Any lookup to the http.port property name will first search by the active profile name %dev.http.port and then fallback to http.port if no value is present. In this case a lookup to the property http.port with the dev profile active, yields the value 8181 . Attention The profile must be set in one of the primary sources (system properties, environment variables, application.properties , or any other source that does not require configuration) to determine the proper configuration.","title":"Profile aware properties"},{"location":"config/profiles/#profile-aware-files","text":"Properties for a specific profile may reside in a microprofile-config-{profile}.properties named file. The previous example can be expressed as: META-INF/microprofile-config.properties http.port = 8080 META-INF/microprofile-config-dev.properties http.port = 8181 In this style, the property names in the profile aware file do not need to be prefixed with the profile name. Note Properties in the profile aware file have priority over profile aware properties defined in the main file. Attention Do not use Profile aware files to set smallrye.config.profile . This will not work because the the profile is required in advance to load the profile aware files.","title":"Profile aware files"},{"location":"config/profiles/#priority","text":"Profile lookups are only valid if the ConfigSource has a higher ordinal than a lookup to the regular configuration name. Consider: main.properties config_ordinal = 1000 http.port = 8080 profile.properties config_ordinal = 100 %dev.http.port = 8181 Even with the profile dev active, the lookup value for my.prop is 1234 . This prevents lower ordinal sources to set a profile property value that cannot be overridden unless the profile property is also overridden.","title":"Priority"},{"location":"config/profiles/#multiple-profiles","text":"Multiple Profiles may be active at the same time. The configuration smallrye.config.profile accepts a comma-separated list of profile names: smallrye.config.profile=common,dev . Both common and dev are separate profiles. When multiple profiles are active, the rules for profile configuration are the same. If two profiles define the same configuration, then the last listed profile has priority. Consider: smallrye.config.profile = common,dev my.prop = 1234 %common.my.prop = 1234 %dev.my.prop = 5678 %common.commom.prop = common %dev.dev.prop = dev %test.test.prop = test Then common.prop value is common dev.prop value is dev my.prop value is 5678 test.prop does not have a value It is also possible to define multiple profile properties, with a comma-separated list of profile names: %prod,dev.my.prop = 1234 The property name common.prop is active in both dev and prod profile. If the same property name exists in multiple profile properties then, the property name with the most specific profile wins: smallrye.config.profile = dev %prod,dev.my.prop = 1234 %dev.my.prop = 5678 Then my.prop value is 5678 .","title":"Multiple Profiles"},{"location":"config/profiles/#parent-profile","text":"A Parent Profile adds multiple levels of hierarchy to the current profile. The configuration smallrye.config.profile.parent also acccepts a comma-separated list of profile names. When the Parent Profile is active, if a property cannot be found in the current active Profile, the config lookup fallbacks to the Parent Profile. Consider: smallrye.config.profile = dev smallrye.config.profile.parent = common my.prop = 1234 %common.my.prop = 0 %dev.my.prop = 5678 %common.commom.prop = common %dev.dev.prop = dev %test.test.prop = test Then common.prop value is common dev.prop value is dev my.prop value is 0 test.prop does not have a value Attention Do not use Profile aware files to set smallrye.config.profile.parent`. This will not work because the the profile is required in advance to load the profile aware files.","title":"Parent Profile"},{"location":"config/profiles/#multi-level-hierarchy","text":"The Parent Profile also supports multiple levels of hierarchies: smallrye.config.profile = child %child.smallrye.config.profile.parent = parent %parent.smallrye.config.profile.parent = grandparent %grandparent.smallrye.config.profile.parent = greatgrandparent %greatgrandparent.smallrye.config.profile.parent = end Will load the following profiles in order: child , parent , grandparent , greatgrandparent , end","title":"Multi-level Hierarchy"},{"location":"config/secret-keys/","text":"Secret Keys # Secret Keys Expressions # In SmallRye Config, a secret configuration may be expressed as ${handler::value} , where the handler is the name of a io.smallrye.config.SecretKeysHandler to decode or decrypt the value separated by a double colon :: . It is possible to create a custom SecretKeysHandler and provide different ways to decode or decrypt configuration values. A custom SecretKeysHandler requires an implementation of io.smallrye.config.SecretKeysHandler or io.smallrye.config.SecretKeysHandlerFactory . Each implementation requires registration via the ServiceLoader mechanism, either in META-INF/services/io.smallrye.config.SecretKeysHandler or META-INF/services/io.smallrye.config.SecretKeysHandlerFactory files. Danger It is not possible to mix Secret Keys Expressions with Property Expressions. Crypto # The smallrye-config-crypto artifact contains a few out-of-the-box SecretKeysHandler s ready for use. It requires the following dependency: <dependency> <groupId> io.smallrye.config </groupId> <artifactId> smallrye-config-crypto </artifactId> <version> 3.9.1-SNAPSHOT </version> </dependency> AES/GCM/NoPadding ${aes-gcm-nopadding::...} # The encoding length is 128. The secret and the encryption key (without padding) must be base 64 encoded. Example application.properties smallrye.config.secret-handler.aes-gcm-nopadding.encryption-key = DDne5obnfH1RSeTg71xSZg my.secret = ${aes-gcm-nopadding::DLTb_9zxThxeT5iAQqswEl5Dn1ju4FdM9hIyVip35t5V} The ${aes-gcm-nopadding::...} SecretKeyHandler requires smallrye.config.secret-handler.aes-gcm-nopadding.encryption-key configuration to state the encryption key to be used by the aes-gcm-nopaddin handler. A lookup to my.secret will use the SecretKeysHandler name aes-gcm-nopadding to decode the value DJNrZ6LfpupFv6QbXyXhvzD8eVDnDa_kTliQBpuzTobDZxlg . Info It is possible to generate the encrypted secret with the following JBang script: jbang https://raw.githubusercontent.com/smallrye/smallrye-config/main/documentation/src/main/docs/config/secret-handlers/encryptor.java -s = <secret> -k = <encryptionKey> ` Configuration # Configuration Property Type Default smallrye.config.secret-handler.aes-gcm-nopadding.encryption-key The encryption key to use to decode secrets encoded by the AES/GCM/NoPadding algorithm. String \"smallrye.config.secret-handler.aes-gcm-nopadding.encryption-key-decode\" Decode the encryption key in Base64, if the plain text key was used to encrypt the secret. boolean false Jasypt # Jasypt is a java library which allows the developer to add basic encryption capabilities. Add the following dependency in your project to use it: <dependency> <groupId> io.smallrye.config </groupId> <artifactId> smallrye-config-jasypt </artifactId> <version> 3.9.1-SNAPSHOT </version> </dependency> Jasypt ${jasypt::...} # Example application.properties smallrye.config.secret-handler.jasypt.password = jasypt smallrye.config.secret-handler.jasypt.algorithm = PBEWithHMACSHA512AndAES_256 my.secret = ${jasypt::ENC(wqp8zDeiCQ5JaFvwDtoAcr2WMLdlD0rjwvo8Rh0thG5qyTQVGxwJjBIiW26y0dtU)} The ${jasypt::...} SecretKeyHandler requires both smallrye.config.secret-handler.jasypt.password and smallrye.config.secret-handler.jasypt.algorithm configurations to state the password and the algorithm to be used by the Jasypt encryptor. Jasypt encrypted values must be set with the handler expression as ${jasypt::ENC(value)} . Note that the encrypted value must be generated using the proper Jasypt encryptor with the same password and algorithm set in the confguration. A possible encrypted value for 12345678 is ENC(wqp8zDeiCQ5JaFvwDtoAcr2WMLdlD0rjwvo8Rh0thG5qyTQVGxwJjBIiW26y0dtU) Lookups to the configuration my.secret will automatically decrypt the value with Jasypt and provide the original 12345678 string. Info It is possible to generate the encrypted secret with the following JBang script: jbang https://raw.githubusercontent.com/smallrye/smallrye-config/main/documentation/src/main/docs/config/secret-handlers/jasypt.java -s = <secret> -p = <password> Configuration # Configuration Property Type Default smallrye.config.secret-handler.jasypt.password The Jasypt password to use String smallrye.config.secret-handler.jasypt.algorithm The Jasypt algorithm to use String Secret Keys Names # When configuration properties contain passwords or other kinds of secrets, Smallrye Config can hide them to prevent accidental exposure of such values. This is no way a replacement for securing secrets. Proper security mechanisms must still be used to secure secrets. However, there is still the fundamental problem that passwords and secrets are generally encoded simply as strings. Secret Keys provides a way to \u201clock\u201d the configuration so that secrets do not appear unless explicitly enabled. To mark specific keys as secrets, register an instance of io.smallrye.config.SecretKeysConfigSourceInterceptor by using the interceptor factory as follows: public class SecretKeysConfigInterceptorFactory implements ConfigSourceInterceptorFactory { @Override public ConfigSourceInterceptor getInterceptor ( ConfigSourceInterceptorContext context ) { return new SecretKeysConfigSourceInterceptor ( Set . of ( \"secret\" )); } } Register the factory so that it can be found at runtime by creating a META-INF/services/io.smallrye.config.ConfigSourceInterceptorFactory file that contains the fully qualified name of this factory class. From this point forward, every lookup to the configuration name secret will throw a SecurityException . Access the Secret Keys using the APIs io.smallrye.config.SecretKeys#doUnlocked(java.lang.Runnable) and io.smallrye.config.SecretKeys#doUnlocked(java.util.function.Supplier<T>) . String secretValue = SecretKeys . doUnlocked (() -> { config . getValue ( \"secret\" , String . class ); }); Secret Keys are only unlocked in the context of doUnlocked . Once the execution completes, the secrets become locked again.","title":"Secret Keys"},{"location":"config/secret-keys/#secret-keys","text":"","title":"Secret Keys"},{"location":"config/secret-keys/#secret-keys-expressions","text":"In SmallRye Config, a secret configuration may be expressed as ${handler::value} , where the handler is the name of a io.smallrye.config.SecretKeysHandler to decode or decrypt the value separated by a double colon :: . It is possible to create a custom SecretKeysHandler and provide different ways to decode or decrypt configuration values. A custom SecretKeysHandler requires an implementation of io.smallrye.config.SecretKeysHandler or io.smallrye.config.SecretKeysHandlerFactory . Each implementation requires registration via the ServiceLoader mechanism, either in META-INF/services/io.smallrye.config.SecretKeysHandler or META-INF/services/io.smallrye.config.SecretKeysHandlerFactory files. Danger It is not possible to mix Secret Keys Expressions with Property Expressions.","title":"Secret Keys Expressions"},{"location":"config/secret-keys/#crypto","text":"The smallrye-config-crypto artifact contains a few out-of-the-box SecretKeysHandler s ready for use. It requires the following dependency: <dependency> <groupId> io.smallrye.config </groupId> <artifactId> smallrye-config-crypto </artifactId> <version> 3.9.1-SNAPSHOT </version> </dependency>","title":"Crypto"},{"location":"config/secret-keys/#jasypt","text":"Jasypt is a java library which allows the developer to add basic encryption capabilities. Add the following dependency in your project to use it: <dependency> <groupId> io.smallrye.config </groupId> <artifactId> smallrye-config-jasypt </artifactId> <version> 3.9.1-SNAPSHOT </version> </dependency>","title":"Jasypt"},{"location":"config/secret-keys/#secret-keys-names","text":"When configuration properties contain passwords or other kinds of secrets, Smallrye Config can hide them to prevent accidental exposure of such values. This is no way a replacement for securing secrets. Proper security mechanisms must still be used to secure secrets. However, there is still the fundamental problem that passwords and secrets are generally encoded simply as strings. Secret Keys provides a way to \u201clock\u201d the configuration so that secrets do not appear unless explicitly enabled. To mark specific keys as secrets, register an instance of io.smallrye.config.SecretKeysConfigSourceInterceptor by using the interceptor factory as follows: public class SecretKeysConfigInterceptorFactory implements ConfigSourceInterceptorFactory { @Override public ConfigSourceInterceptor getInterceptor ( ConfigSourceInterceptorContext context ) { return new SecretKeysConfigSourceInterceptor ( Set . of ( \"secret\" )); } } Register the factory so that it can be found at runtime by creating a META-INF/services/io.smallrye.config.ConfigSourceInterceptorFactory file that contains the fully qualified name of this factory class. From this point forward, every lookup to the configuration name secret will throw a SecurityException . Access the Secret Keys using the APIs io.smallrye.config.SecretKeys#doUnlocked(java.lang.Runnable) and io.smallrye.config.SecretKeys#doUnlocked(java.util.function.Supplier<T>) . String secretValue = SecretKeys . doUnlocked (() -> { config . getValue ( \"secret\" , String . class ); }); Secret Keys are only unlocked in the context of doUnlocked . Once the execution completes, the secrets become locked again.","title":"Secret Keys Names"},{"location":"config-sources/custom/","text":"Config Sources # Custom ConfigSource # It\u2019s possible to create a custom ConfigSource as specified in MicroProfile Config . With a Custom ConfigSource it is possible to read additional configuration values and add them to the Config instance in a defined ordinal. This allows overriding values from other sources or falling back to other values. A custom ConfigSource requires an implementation of org.eclipse.microprofile.config.spi.ConfigSource or org.eclipse.microprofile.config.spi.ConfigSourceProvider . Each implementation requires registration via the ServiceLoader mechanism, either in META-INF/services/org.eclipse.microprofile.config.spi.ConfigSource or META-INF/services/org.eclipse.microprofile.config.spi.ConfigSourceProvider files. Consider a simple in-memory ConfigSource: package org.acme.config ; import org.eclipse.microprofile.config.spi.ConfigSource ; import java.util.HashMap ; import java.util.Map ; import java.util.Set ; public class InMemoryConfigSource implements ConfigSource { private static final Map < String , String > configuration = new HashMap <> (); static { configuration . put ( \"my.prop\" , \"1234\" ); } @Override public int getOrdinal () { return 275 ; } @Override public Set < String > getPropertyNames () { return configuration . keySet (); } @Override public String getValue ( final String propertyName ) { return configuration . get ( propertyName ); } @Override public String getName () { return InMemoryConfigSource . class . getSimpleName (); } } And registration in: META-INF/services/org.eclipse.microprofile.config.spi.ConfigSource org.acme.config.InMemoryConfigSource The InMemoryConfigSource will be ordered between the System properties config source, and the Environment variables config source due to the 350 ordinal. In this case, my.prop from InMemoryConfigSource will only be used if the Config instance is unable to find a value in System Properties , ignoring all the other lower ordinal config sources. ConfigSourceFactory # Another way to create a ConfigSource is via the SmallRye Config io.smallrye.config.ConfigSourceFactory API. The difference between the SmallRye Config factory and the standard way to create a ConfigSource as specified in MicroProfile Config , is the factory ability to provide a context with access to the current configuration. Each implementation of io.smallrye.config.ConfigSourceFactory requires registration via the ServiceLoader mechanism in the META-INF/services/io.smallrye.config.ConfigSourceFactory file. package org.acme.config ; import java.util.Collections ; import java.util.OptionalInt ; import org.eclipse.microprofile.config.spi.ConfigSource ; import io.smallrye.config.ConfigSourceContext ; import io.smallrye.config.ConfigSourceFactory ; import io.smallrye.config.ConfigValue ; import io.smallrye.config.PropertiesConfigSource ; public class URLConfigSourceFactory implements ConfigSourceFactory { @Override public Iterable < ConfigSource > getConfigSources ( final ConfigSourceContext context ) { final ConfigValue value = context . getValue ( \"config.url\" ); if ( value == null || value . getValue () == null ) { return Collections . emptyList (); } try { return Collections . singletonList ( new PropertiesConfigSource ( new URL ( value . getValue ()))); } catch ( IOException e ) { throw new RuntimeException ( e ); } } @Override public OptionalInt getPriority () { return OptionalInt . of ( 290 ); } } And registration in: META-INF/services/io.smallrye.config.ConfigSourceFactory org.acme.config.URLConfigSourceFactory By implementing io.smallrye.config.ConfigSourceFactory , a list of ConfigSource may be provided via the Iterable<ConfigSource> getConfigSources(ConfigSourceContext context) method. The ConfigSourceFactory may also assign a priority by overriding the method OptionalInt getPriority() . The priority value is used to sort multiple io.smallrye.config.ConfigSourceFactory (if found). Higher the value, higher the priority. Warning The io.smallrye.config.ConfigSourceFactory priority does not affect the ConfigSource ordinal. These are sorted independently. When the Factory is initializing, the provided ConfigSourceContext may call the method ConfigValue getValue(String name) . This method looks up configuration names in all ConfigSource s that were already initialized by the Config instance, including sources with lower ordinals than the ones defined in the ConfigSourceFactory . This means that a Config instance is initialized in two steps: first all ConfigSource and ConfigSourceProvider and then the ConfigSourceFactory . Only configuation values found in the first step are avaible to the `ConfigSourceFactory. The ConfigSource list provided by a ConfigSourceFactory is not taken into consideration to configure other sources produced by a lower priority ConfigSourceFactory . Override ConfigSource ordinal # The special configuration property name config_ordinal can be set in any ConfigSource to override its default ordinal. For instance, setting the system property -Dconfig_ordinal=200 will override the ordinal for the System properties config source and move it to be looked up after the Environment Variables config source. Properties # The PropertiesConfigSource creates a ConfigSource from Java Properties , Map<String, String> objects or a .properties file (referenced by its URL). Config Value Properties # The ConfigValuePropertiesConfigSource a ConfigSource from Java Properties , Map<String, String> objects or a .properties file (referenced by its URL) with support for io.smallrye.config.ConfigValue . .env # The DotEnvConfigSourceProvider create a ConfigSource from a .env file.","title":"Custom"},{"location":"config-sources/custom/#config-sources","text":"","title":"Config Sources"},{"location":"config-sources/custom/#custom-configsource","text":"It\u2019s possible to create a custom ConfigSource as specified in MicroProfile Config . With a Custom ConfigSource it is possible to read additional configuration values and add them to the Config instance in a defined ordinal. This allows overriding values from other sources or falling back to other values. A custom ConfigSource requires an implementation of org.eclipse.microprofile.config.spi.ConfigSource or org.eclipse.microprofile.config.spi.ConfigSourceProvider . Each implementation requires registration via the ServiceLoader mechanism, either in META-INF/services/org.eclipse.microprofile.config.spi.ConfigSource or META-INF/services/org.eclipse.microprofile.config.spi.ConfigSourceProvider files. Consider a simple in-memory ConfigSource: package org.acme.config ; import org.eclipse.microprofile.config.spi.ConfigSource ; import java.util.HashMap ; import java.util.Map ; import java.util.Set ; public class InMemoryConfigSource implements ConfigSource { private static final Map < String , String > configuration = new HashMap <> (); static { configuration . put ( \"my.prop\" , \"1234\" ); } @Override public int getOrdinal () { return 275 ; } @Override public Set < String > getPropertyNames () { return configuration . keySet (); } @Override public String getValue ( final String propertyName ) { return configuration . get ( propertyName ); } @Override public String getName () { return InMemoryConfigSource . class . getSimpleName (); } } And registration in: META-INF/services/org.eclipse.microprofile.config.spi.ConfigSource org.acme.config.InMemoryConfigSource The InMemoryConfigSource will be ordered between the System properties config source, and the Environment variables config source due to the 350 ordinal. In this case, my.prop from InMemoryConfigSource will only be used if the Config instance is unable to find a value in System Properties , ignoring all the other lower ordinal config sources.","title":"Custom ConfigSource"},{"location":"config-sources/custom/#configsourcefactory","text":"Another way to create a ConfigSource is via the SmallRye Config io.smallrye.config.ConfigSourceFactory API. The difference between the SmallRye Config factory and the standard way to create a ConfigSource as specified in MicroProfile Config , is the factory ability to provide a context with access to the current configuration. Each implementation of io.smallrye.config.ConfigSourceFactory requires registration via the ServiceLoader mechanism in the META-INF/services/io.smallrye.config.ConfigSourceFactory file. package org.acme.config ; import java.util.Collections ; import java.util.OptionalInt ; import org.eclipse.microprofile.config.spi.ConfigSource ; import io.smallrye.config.ConfigSourceContext ; import io.smallrye.config.ConfigSourceFactory ; import io.smallrye.config.ConfigValue ; import io.smallrye.config.PropertiesConfigSource ; public class URLConfigSourceFactory implements ConfigSourceFactory { @Override public Iterable < ConfigSource > getConfigSources ( final ConfigSourceContext context ) { final ConfigValue value = context . getValue ( \"config.url\" ); if ( value == null || value . getValue () == null ) { return Collections . emptyList (); } try { return Collections . singletonList ( new PropertiesConfigSource ( new URL ( value . getValue ()))); } catch ( IOException e ) { throw new RuntimeException ( e ); } } @Override public OptionalInt getPriority () { return OptionalInt . of ( 290 ); } } And registration in: META-INF/services/io.smallrye.config.ConfigSourceFactory org.acme.config.URLConfigSourceFactory By implementing io.smallrye.config.ConfigSourceFactory , a list of ConfigSource may be provided via the Iterable<ConfigSource> getConfigSources(ConfigSourceContext context) method. The ConfigSourceFactory may also assign a priority by overriding the method OptionalInt getPriority() . The priority value is used to sort multiple io.smallrye.config.ConfigSourceFactory (if found). Higher the value, higher the priority. Warning The io.smallrye.config.ConfigSourceFactory priority does not affect the ConfigSource ordinal. These are sorted independently. When the Factory is initializing, the provided ConfigSourceContext may call the method ConfigValue getValue(String name) . This method looks up configuration names in all ConfigSource s that were already initialized by the Config instance, including sources with lower ordinals than the ones defined in the ConfigSourceFactory . This means that a Config instance is initialized in two steps: first all ConfigSource and ConfigSourceProvider and then the ConfigSourceFactory . Only configuation values found in the first step are avaible to the `ConfigSourceFactory. The ConfigSource list provided by a ConfigSourceFactory is not taken into consideration to configure other sources produced by a lower priority ConfigSourceFactory .","title":"ConfigSourceFactory"},{"location":"config-sources/custom/#override-configsource-ordinal","text":"The special configuration property name config_ordinal can be set in any ConfigSource to override its default ordinal. For instance, setting the system property -Dconfig_ordinal=200 will override the ordinal for the System properties config source and move it to be looked up after the Environment Variables config source.","title":"Override ConfigSource ordinal"},{"location":"config-sources/custom/#properties","text":"The PropertiesConfigSource creates a ConfigSource from Java Properties , Map<String, String> objects or a .properties file (referenced by its URL).","title":"Properties"},{"location":"config-sources/custom/#config-value-properties","text":"The ConfigValuePropertiesConfigSource a ConfigSource from Java Properties , Map<String, String> objects or a .properties file (referenced by its URL) with support for io.smallrye.config.ConfigValue .","title":"Config Value Properties"},{"location":"config-sources/custom/#env","text":"The DotEnvConfigSourceProvider create a ConfigSource from a .env file.","title":".env"},{"location":"config-sources/factories/","text":"Config Source Factory # Another way to create a ConfigSource is via the ConfigSourceFactory . The difference between the SmallRye Config Factory and the standard way to make a ConfigSource as specified in MicroProfile Config is the Factory\u2019s ability to provide a context with access to the available configuration. With the ConfigSourceFactory it is possible to bootstrap a ConfigSource that configures itself with previously initialized ConfigSource's . By implementing ConfigSourceFactory , a list of ConfigSource's may be provided via the Iterable<ConfigSource> getConfigSources(ConfigSourceContext context) method. The ConfigSourceFactory may also assign a priority by overriding the default method OptionalInt getPriority() . The priority only sorts the factories during initialization. After initialization, the provided ConfigSources will use their own ordinal and sorted with all ConfigSources available in the Config instance. When the Factory initializes, the provided ConfigSourceContext may call the method ConfigValue getValue(String name) . This method looks up configuration names in all ConfigSource's already initialized by the Config instance, including sources with lower ordinals than the ones defined in the ConfigSourceFactory . The ConfigSourceFactory does not consider ConfigSources's provided by other ConfigSourceFactory's (the priority does not matter). Registration of a ConfigSourceFactory is done via the ServiceLoader mechanism by providing the implementation classes in a META-INF/services/io.smallrye.config.ConfigSourceFactory file. Alternatively, factories may be registered via the Programmatic API in SmallRyeConfigBuilder#withSources . A ConfigSourceFactory requires an implementation of io.smallrye.config.ConfigSourceFactory . Each implementation requires registration via the ServiceLoader mechanism in the META-INF/services/io.smallrye.config.ConfigSourceFactory file. Alternatively, interceptors may be registered via the Programmatic API in SmallRyeConfigBuilder#withSources . package org.acme.config import java.io.IOException ; import java.net.MalformedURLException ; import java.net.URI ; import java.net.URISyntaxException ; import java.net.URL ; import java.util.Collections ; import java.util.List ; import org.eclipse.microprofile.config.spi.ConfigSource ; import io.smallrye.config._private.ConfigMessages ; import io.smallrye.config.PropertiesConfigSource ; import io.smallrye.config.ConfigSourceContext ; import io.smallrye.config.ConfigSourceFactory ; import io.smallrye.config.ConfigValue ; public class FileSystemConfigSourceFactory implements ConfigSourceFactory { @Override public Iterable < ConfigSource > getConfigSources ( final ConfigSourceContext context ) { final ConfigValue value = context . getValue ( \"org.acme.config.file.locations\" ); if ( value == null || value . getValue () == null ) { return Collections . emptyList (); } try { return List . of ( new PropertiesConfigSource ( toURL ( value . getValue ()), 250 )); } catch ( IOException e ) { return Collections . emptyList (); } } private URL toURL ( final String value ) { try { return new URI ( value ). toURL (); } catch ( URISyntaxException | MalformedURLException e ) { throw ConfigMessages . msg . uriSyntaxInvalid ( e , value ); } } } And registration in: META-INF/services/io.smallrye.config.ConfigSourceFactory org.acme.config.FileSystemConfigSourceFactory The FileSystemConfigSourceFactory look ups the configuration value for org.acme.config.file.locations , and uses it to set up an additional ConfigSource . Alternatively, a ConfigurableConfigSourceFactory accepts a ConfigMapping interface to configure the ConfigSource : @ConfigMapping ( prefix = \"org.acme.config.file\" ) interface FileSystemConfig { List < URL > locations (); } public class FileSystemConfigurableConfigSourceFactory implements ConfigurableConfigSourceFactory < FileSystemConfig > { @Override public Iterable < ConfigSource > getConfigSources ( ConfigSourceContext context , FileSystemConfig config ) { } } With a ConfigurableConfigSourceFactory it is not required to look up the configuration values with ConfigSourceContext . The values are automatically mapped with the defined @ConfigMapping .","title":"Factories"},{"location":"config-sources/factories/#config-source-factory","text":"Another way to create a ConfigSource is via the ConfigSourceFactory . The difference between the SmallRye Config Factory and the standard way to make a ConfigSource as specified in MicroProfile Config is the Factory\u2019s ability to provide a context with access to the available configuration. With the ConfigSourceFactory it is possible to bootstrap a ConfigSource that configures itself with previously initialized ConfigSource's . By implementing ConfigSourceFactory , a list of ConfigSource's may be provided via the Iterable<ConfigSource> getConfigSources(ConfigSourceContext context) method. The ConfigSourceFactory may also assign a priority by overriding the default method OptionalInt getPriority() . The priority only sorts the factories during initialization. After initialization, the provided ConfigSources will use their own ordinal and sorted with all ConfigSources available in the Config instance. When the Factory initializes, the provided ConfigSourceContext may call the method ConfigValue getValue(String name) . This method looks up configuration names in all ConfigSource's already initialized by the Config instance, including sources with lower ordinals than the ones defined in the ConfigSourceFactory . The ConfigSourceFactory does not consider ConfigSources's provided by other ConfigSourceFactory's (the priority does not matter). Registration of a ConfigSourceFactory is done via the ServiceLoader mechanism by providing the implementation classes in a META-INF/services/io.smallrye.config.ConfigSourceFactory file. Alternatively, factories may be registered via the Programmatic API in SmallRyeConfigBuilder#withSources . A ConfigSourceFactory requires an implementation of io.smallrye.config.ConfigSourceFactory . Each implementation requires registration via the ServiceLoader mechanism in the META-INF/services/io.smallrye.config.ConfigSourceFactory file. Alternatively, interceptors may be registered via the Programmatic API in SmallRyeConfigBuilder#withSources . package org.acme.config import java.io.IOException ; import java.net.MalformedURLException ; import java.net.URI ; import java.net.URISyntaxException ; import java.net.URL ; import java.util.Collections ; import java.util.List ; import org.eclipse.microprofile.config.spi.ConfigSource ; import io.smallrye.config._private.ConfigMessages ; import io.smallrye.config.PropertiesConfigSource ; import io.smallrye.config.ConfigSourceContext ; import io.smallrye.config.ConfigSourceFactory ; import io.smallrye.config.ConfigValue ; public class FileSystemConfigSourceFactory implements ConfigSourceFactory { @Override public Iterable < ConfigSource > getConfigSources ( final ConfigSourceContext context ) { final ConfigValue value = context . getValue ( \"org.acme.config.file.locations\" ); if ( value == null || value . getValue () == null ) { return Collections . emptyList (); } try { return List . of ( new PropertiesConfigSource ( toURL ( value . getValue ()), 250 )); } catch ( IOException e ) { return Collections . emptyList (); } } private URL toURL ( final String value ) { try { return new URI ( value ). toURL (); } catch ( URISyntaxException | MalformedURLException e ) { throw ConfigMessages . msg . uriSyntaxInvalid ( e , value ); } } } And registration in: META-INF/services/io.smallrye.config.ConfigSourceFactory org.acme.config.FileSystemConfigSourceFactory The FileSystemConfigSourceFactory look ups the configuration value for org.acme.config.file.locations , and uses it to set up an additional ConfigSource . Alternatively, a ConfigurableConfigSourceFactory accepts a ConfigMapping interface to configure the ConfigSource : @ConfigMapping ( prefix = \"org.acme.config.file\" ) interface FileSystemConfig { List < URL > locations (); } public class FileSystemConfigurableConfigSourceFactory implements ConfigurableConfigSourceFactory < FileSystemConfig > { @Override public Iterable < ConfigSource > getConfigSources ( ConfigSourceContext context , FileSystemConfig config ) { } } With a ConfigurableConfigSourceFactory it is not required to look up the configuration values with ConfigSourceContext . The values are automatically mapped with the defined @ConfigMapping .","title":"Config Source Factory"},{"location":"config-sources/filesystem/","text":"FileSystem Config Source # This Config Source loads configuration values for each file found in a directory. Each file corresponds to a single property, where the file name is the configuration property name and the file content the configuration value. For instance, if a directory structure looks like: foo/ |__num.max |__num.size The FileSystem Config Source will provide 2 properties: num.max num.size Warning Nested directories are not supported. This Config Source can be used to read configuration from Kubernetes ConfigMap . Check the Kubernetes ConfigMap ConfigSource Example . The same mapping rules as defined for environment variables are applied, so the FileSystem Config Source will search for a given property name num.max : Exact match ( num.max ) Replace each character that is neither alphanumeric nor _ with _ ( num_max ) Replace each character that is neither alphanumeric nor _ with _; then convert the name to upper case ( NUM_MAX ) The following dependency is required in the classpath to use the FileSystem Config Source: <dependency> <groupId> io.smallrye.config </groupId> <artifactId> smallrye-config-source-file-system </artifactId> <version> 3.9.1-SNAPSHOT </version> </dependency> The configuration property smallrye.config.source.file.locations sets the directory paths to look up the files. It accepts multiple locations separated by a comma and each must represent a valid URI to a directory.","title":"FileSystem"},{"location":"config-sources/filesystem/#filesystem-config-source","text":"This Config Source loads configuration values for each file found in a directory. Each file corresponds to a single property, where the file name is the configuration property name and the file content the configuration value. For instance, if a directory structure looks like: foo/ |__num.max |__num.size The FileSystem Config Source will provide 2 properties: num.max num.size Warning Nested directories are not supported. This Config Source can be used to read configuration from Kubernetes ConfigMap . Check the Kubernetes ConfigMap ConfigSource Example . The same mapping rules as defined for environment variables are applied, so the FileSystem Config Source will search for a given property name num.max : Exact match ( num.max ) Replace each character that is neither alphanumeric nor _ with _ ( num_max ) Replace each character that is neither alphanumeric nor _ with _; then convert the name to upper case ( NUM_MAX ) The following dependency is required in the classpath to use the FileSystem Config Source: <dependency> <groupId> io.smallrye.config </groupId> <artifactId> smallrye-config-source-file-system </artifactId> <version> 3.9.1-SNAPSHOT </version> </dependency> The configuration property smallrye.config.source.file.locations sets the directory paths to look up the files. It accepts multiple locations separated by a comma and each must represent a valid URI to a directory.","title":"FileSystem Config Source"},{"location":"config-sources/hocon/","text":"HOCON Config Source # This Config Source allows to use the HOCON file format to load configuration values. The HOCON Config Source loads the configuration from the file META-INF/microprofile-config.conf . It has a lower ordinal ( 50 ) than the microprofile-config.properties . The following dependency is required in the classpath to use the HOCON Config Source: <dependency> <groupId> io.smallrye.config </groupId> <artifactId> smallrye-config-source-hocon </artifactId> <version> 3.9.1-SNAPSHOT </version> </dependency> Expressions defined as ${value} (unquoted) are resolved internally by the HOCON Config Source as described in the HOCON Substitutions documentation. Quoted Expressions defined as \"${value}\" are resolved by SmallRye Config Property Expressions . Consider: hocon.conf { foo: \"bar\", hocon: ${foo}, config: \"${foo}\" } application.properties config_ordinal = 1000 foo = baz The value of hocon is bar and the value of config is baz (if the properties source has a higher ordinal).","title":"HOCON"},{"location":"config-sources/hocon/#hocon-config-source","text":"This Config Source allows to use the HOCON file format to load configuration values. The HOCON Config Source loads the configuration from the file META-INF/microprofile-config.conf . It has a lower ordinal ( 50 ) than the microprofile-config.properties . The following dependency is required in the classpath to use the HOCON Config Source: <dependency> <groupId> io.smallrye.config </groupId> <artifactId> smallrye-config-source-hocon </artifactId> <version> 3.9.1-SNAPSHOT </version> </dependency> Expressions defined as ${value} (unquoted) are resolved internally by the HOCON Config Source as described in the HOCON Substitutions documentation. Quoted Expressions defined as \"${value}\" are resolved by SmallRye Config Property Expressions . Consider: hocon.conf { foo: \"bar\", hocon: ${foo}, config: \"${foo}\" } application.properties config_ordinal = 1000 foo = baz The value of hocon is bar and the value of config is baz (if the properties source has a higher ordinal).","title":"HOCON Config Source"},{"location":"config-sources/json/","text":"JSON Config Source # The YAML Config Source also accepts the JSON format as its contents. The configuration file META-INF/microprofile-config.yaml , still requires to use the yaml extension.","title":"JSON"},{"location":"config-sources/json/#json-config-source","text":"The YAML Config Source also accepts the JSON format as its contents. The configuration file META-INF/microprofile-config.yaml , still requires to use the yaml extension.","title":"JSON Config Source"},{"location":"config-sources/keystore/","text":"KeyStore Config Source # This Config Source allows to use a Java KeyStore to load configuration values. It uses an ordinal of 100 . The following dependency is required in the classpath to use the KeyStore Config Source: <dependency> <groupId> io.smallrye.config </groupId> <artifactId> smallrye-config-source-keystore </artifactId> <version> 3.9.1-SNAPSHOT </version> </dependency> Create a KeyStore # The following command creates a simple KeyStore keytool -importpass -alias my.secret -keystore keystore -storepass secret -storetype PKCS12 -v The -alias my.secret stores the configuration property name my.secret in the KeyStore. The command will interactively ask for the value to be stored in the KeyStore. Read the KeyStore # The KeyStore Config Source supports reading multiple keystore files: smallrye.config.source.keystore.one.path = keystore-one smallrye.config.source.keystore.one.password = password smallrye.config.source.keystore.two.path = keystore-two smallrye.config.source.keystore.two.password = password The names are arbitrary and can be any name. The name one and two are used to distinguish both KeyStores. If a stored configuration property requires a Secret Handler to decode a value, set the handler name with smallrye.config.source.keystore.\"name\".handler . Configuration # Configuration Property Type Default smallrye.config.source.keystore.\"name\".path The KeyStore path. String smallrye.config.source.keystore.\"name\".password The KeyStore password. String smallrye.config.source.keystore.\"name\".type The KeyStore type. String PKCS12 smallrye.config.source.keystore.\"name\".handler An Optional secret keys handler. String smallrye.config.source.keystore.\"name\".aliases.\"key\".name An Optional aliases key name. String smallrye.config.source.keystore.\"name\".aliases.\"key\".password An Optional aliases key password. String smallrye.config.source.keystore.\"name\".aliases.\"key\".handler An Optional aliases key secret keys handler. String","title":"KeyStore"},{"location":"config-sources/keystore/#keystore-config-source","text":"This Config Source allows to use a Java KeyStore to load configuration values. It uses an ordinal of 100 . The following dependency is required in the classpath to use the KeyStore Config Source: <dependency> <groupId> io.smallrye.config </groupId> <artifactId> smallrye-config-source-keystore </artifactId> <version> 3.9.1-SNAPSHOT </version> </dependency>","title":"KeyStore Config Source"},{"location":"config-sources/keystore/#create-a-keystore","text":"The following command creates a simple KeyStore keytool -importpass -alias my.secret -keystore keystore -storepass secret -storetype PKCS12 -v The -alias my.secret stores the configuration property name my.secret in the KeyStore. The command will interactively ask for the value to be stored in the KeyStore.","title":"Create a KeyStore"},{"location":"config-sources/keystore/#read-the-keystore","text":"The KeyStore Config Source supports reading multiple keystore files: smallrye.config.source.keystore.one.path = keystore-one smallrye.config.source.keystore.one.password = password smallrye.config.source.keystore.two.path = keystore-two smallrye.config.source.keystore.two.password = password The names are arbitrary and can be any name. The name one and two are used to distinguish both KeyStores. If a stored configuration property requires a Secret Handler to decode a value, set the handler name with smallrye.config.source.keystore.\"name\".handler .","title":"Read the KeyStore"},{"location":"config-sources/keystore/#configuration","text":"Configuration Property Type Default smallrye.config.source.keystore.\"name\".path The KeyStore path. String smallrye.config.source.keystore.\"name\".password The KeyStore password. String smallrye.config.source.keystore.\"name\".type The KeyStore type. String PKCS12 smallrye.config.source.keystore.\"name\".handler An Optional secret keys handler. String smallrye.config.source.keystore.\"name\".aliases.\"key\".name An Optional aliases key name. String smallrye.config.source.keystore.\"name\".aliases.\"key\".password An Optional aliases key password. String smallrye.config.source.keystore.\"name\".aliases.\"key\".handler An Optional aliases key secret keys handler. String","title":"Configuration"},{"location":"config-sources/locations/","text":"Locations # Additionally, to the default config locations specified by the MicroProfile Config specification, SmallRye Config provides a way to scan additional locations for configuration properties files. The smallrye.config.locations configuration property accepts multiple locations separated by a comma , and each ust represent a valid URI . The supported URI schemes are: file or directory ( file: ) classpath resource jar resource ( jar: ) http resource ( http: ) Each URI scheme loads all discovered resources in a ConfigSource . All loaded sources use the same ordinal of the source that found the smallrye.config.locations configuration property. For instance, if smallrye.config.locations is set as a system property, then all loaded sources have their ordinals set to 400 (system properties use 400 as their ordinal). The ordinal may be overridden directly in the resource by setting the config_ordinal property. Sources are sorted first by their ordinal, then by location order, and finally by loading order. If a profile is active, and the URI represents a single resource (for instance a file), then resources that match the active profile are also loaded. The profile resource name must follow the pattern: {location}-{profile} . A profile resource is only loaded if the unprofiled resource is also available in the same location. This is to keep a consistent loading order and pair all the resources together. Profile resources are not taken into account if the location is a directory since there is no reliable way to discover which file is the main resource. Properties that use the profile prefix syntax %profile. will work as expected. All properties files from a directory # loads all files from a relative path smallrye.config.locations = ./src/main/resources/ # loads all files from an absolute path smallrye.config.locations = /user/local/config For relative paths, the JVM user.dir property defines the current directory. A specific file ./src/main/resources/additional.properties smallrye.config.locations = ./src/main/resources/additional.properties If a profile dev is active, and an additional-dev.properties file exists, this will also be loaded. All additional.properties files from the classpath additional.properties smallrye.config.locations = additional.properties If a profile prod is active, and an additional-prod.properties resources exists next to the additional.properties resource, this will also be loaded. The resources.properties file from a specific jar jar:file:///user/local/app/lib/resources-.jar!/resources.properties smallrye.config.locations = jar:file:///user/local/app/lib/resources-.jar!/resources.properties If a profile test is active, and an additional-test.properties resource exists, this will also be loaded. The config.properties file from a web server http://localhost:8080/config/config.properties smallrye.config.locations = http://localhost:8080/config/config.properties","title":"Locations"},{"location":"config-sources/locations/#locations","text":"Additionally, to the default config locations specified by the MicroProfile Config specification, SmallRye Config provides a way to scan additional locations for configuration properties files. The smallrye.config.locations configuration property accepts multiple locations separated by a comma , and each ust represent a valid URI . The supported URI schemes are: file or directory ( file: ) classpath resource jar resource ( jar: ) http resource ( http: ) Each URI scheme loads all discovered resources in a ConfigSource . All loaded sources use the same ordinal of the source that found the smallrye.config.locations configuration property. For instance, if smallrye.config.locations is set as a system property, then all loaded sources have their ordinals set to 400 (system properties use 400 as their ordinal). The ordinal may be overridden directly in the resource by setting the config_ordinal property. Sources are sorted first by their ordinal, then by location order, and finally by loading order. If a profile is active, and the URI represents a single resource (for instance a file), then resources that match the active profile are also loaded. The profile resource name must follow the pattern: {location}-{profile} . A profile resource is only loaded if the unprofiled resource is also available in the same location. This is to keep a consistent loading order and pair all the resources together. Profile resources are not taken into account if the location is a directory since there is no reliable way to discover which file is the main resource. Properties that use the profile prefix syntax %profile. will work as expected. All properties files from a directory # loads all files from a relative path smallrye.config.locations = ./src/main/resources/ # loads all files from an absolute path smallrye.config.locations = /user/local/config For relative paths, the JVM user.dir property defines the current directory. A specific file ./src/main/resources/additional.properties smallrye.config.locations = ./src/main/resources/additional.properties If a profile dev is active, and an additional-dev.properties file exists, this will also be loaded. All additional.properties files from the classpath additional.properties smallrye.config.locations = additional.properties If a profile prod is active, and an additional-prod.properties resources exists next to the additional.properties resource, this will also be loaded. The resources.properties file from a specific jar jar:file:///user/local/app/lib/resources-.jar!/resources.properties smallrye.config.locations = jar:file:///user/local/app/lib/resources-.jar!/resources.properties If a profile test is active, and an additional-test.properties resource exists, this will also be loaded. The config.properties file from a web server http://localhost:8080/config/config.properties smallrye.config.locations = http://localhost:8080/config/config.properties","title":"Locations"},{"location":"config-sources/yaml/","text":"YAML Config Source # This Config Source allows to use a yaml file to load configuration values. The YAML Config Source loads the configuration from the following files: ( 265 ) application.yaml|yml in config folder, located in the current working directory ( 255 ) application.yaml|yml in the classpath ( 110 ) MicroProfile Config configuration file META-INF/microprofile-config.yaml|yml in the classpath The following dependency is required in the classpath to use the YAML Config Source: <dependency> <groupId> io.smallrye.config </groupId> <artifactId> smallrye-config-source-yaml </artifactId> <version> 3.9.1-SNAPSHOT </version> </dependency>","title":"YAML"},{"location":"config-sources/yaml/#yaml-config-source","text":"This Config Source allows to use a yaml file to load configuration values. The YAML Config Source loads the configuration from the following files: ( 265 ) application.yaml|yml in config folder, located in the current working directory ( 255 ) application.yaml|yml in the classpath ( 110 ) MicroProfile Config configuration file META-INF/microprofile-config.yaml|yml in the classpath The following dependency is required in the classpath to use the YAML Config Source: <dependency> <groupId> io.smallrye.config </groupId> <artifactId> smallrye-config-source-yaml </artifactId> <version> 3.9.1-SNAPSHOT </version> </dependency>","title":"YAML Config Source"},{"location":"config-sources/zookeeper/","text":"ZooKeeper Config Source # This Config Source allows using Apache ZooKeeper to load configuration values. The following dependency is required in the classpath to use the ZooKeeper Config Source: <dependency> <groupId> io.smallrye.config </groupId> <artifactId> smallrye-config-source-zookeeper </artifactId> <version> 3.9.1-SNAPSHOT </version> </dependency> It also requires to set up additional configuration properties to identify the ZooKeeper instance: io.smallrye.configsource.zookeeper.url = localhost:2181 io.smallrye.configsource.zookeeper.applicationId = applicationId The ZooKeeper Config Source will look for configuration values in a ZooKeeper instance running in the url set in io.smallrye.configsource.zookeeper.url and in the znodes available in /applicationId/ . This Config Source has an ordinal of 150 .","title":"ZooKeeper"},{"location":"config-sources/zookeeper/#zookeeper-config-source","text":"This Config Source allows using Apache ZooKeeper to load configuration values. The following dependency is required in the classpath to use the ZooKeeper Config Source: <dependency> <groupId> io.smallrye.config </groupId> <artifactId> smallrye-config-source-zookeeper </artifactId> <version> 3.9.1-SNAPSHOT </version> </dependency> It also requires to set up additional configuration properties to identify the ZooKeeper instance: io.smallrye.configsource.zookeeper.url = localhost:2181 io.smallrye.configsource.zookeeper.applicationId = applicationId The ZooKeeper Config Source will look for configuration values in a ZooKeeper instance running in the url set in io.smallrye.configsource.zookeeper.url and in the znodes available in /applicationId/ . This Config Source has an ordinal of 150 .","title":"ZooKeeper Config Source"},{"location":"converters/custom/","text":"Custom Converter # It is possible to create a custom Converter type as specified in MicroProfile Config . A custom Converter requires an implementation of org.eclipse.microprofile.config.spi.Converter . Each implementation requires registration via the ServiceLoader mechanism in the META-INF/services/org.eclipse.microprofile.config.spi.Converter file. Consider: package org.acme.config ; public class CustomValue { private final int number ; public CustomValue ( int number ) { this . number = number ; } public int getNumber () { return number ; } } The corresponding converter can look like: package org.acme.config ; import org.eclipse.microprofile.config.spi.Converter ; public class CustomValueConverter implements Converter < CustomValue > { @Override public CustomValue convert ( String value ) { return new CustomValue ( Integer . parseInt ( value )); } } And registration in: META-INF/services/org.eclipse.microprofile.config.spi.Converter org.acme.config.CustomValue Warning The custom Converter class must be public , must have a public constructor with no arguments, and must not be abstract. The CustomValueConverter converts the configuration value to the CustomValue type automatically. Config config = ConfigProvider . getConfig (); CustomValue value = config . getValue ( \"custom.value\" , CustomValue . class ); The jakarta.annotation.Priority annotation overrides the Converter priority and change converters precedence to fine tune the execution order. By default, if no @Priority is specified by the Converter , the converter is registered with a priority of 100 . Consider: package org.acme.config ; import jakarta.annotation.Priority ; import org.eclipse.microprofile.config.spi.Converter ; @Priority ( 150 ) public class SecretConverter implements Converter < CustomValue > { @Override public CustomValue convert ( String value ) { final int secretNumber ; if ( value . startsFrom ( \"OBF:\" )) { secretNumber = Integer . parseInt ( SecretDecoder . decode ( value )); } else { secretNumber = Integer . parseInt ( value ); } return new CustomValue ( secretNumber ); } } Two Converter s, ( CustomValueConverter and SecretConverter ) can convert the same type CustomValue . Since SecretConverter has a priority of 150 , it will be used instead of a CustomValueConverter which has a default priority of 100 (no annotation).","title":"Custom"},{"location":"converters/custom/#custom-converter","text":"It is possible to create a custom Converter type as specified in MicroProfile Config . A custom Converter requires an implementation of org.eclipse.microprofile.config.spi.Converter . Each implementation requires registration via the ServiceLoader mechanism in the META-INF/services/org.eclipse.microprofile.config.spi.Converter file. Consider: package org.acme.config ; public class CustomValue { private final int number ; public CustomValue ( int number ) { this . number = number ; } public int getNumber () { return number ; } } The corresponding converter can look like: package org.acme.config ; import org.eclipse.microprofile.config.spi.Converter ; public class CustomValueConverter implements Converter < CustomValue > { @Override public CustomValue convert ( String value ) { return new CustomValue ( Integer . parseInt ( value )); } } And registration in: META-INF/services/org.eclipse.microprofile.config.spi.Converter org.acme.config.CustomValue Warning The custom Converter class must be public , must have a public constructor with no arguments, and must not be abstract. The CustomValueConverter converts the configuration value to the CustomValue type automatically. Config config = ConfigProvider . getConfig (); CustomValue value = config . getValue ( \"custom.value\" , CustomValue . class ); The jakarta.annotation.Priority annotation overrides the Converter priority and change converters precedence to fine tune the execution order. By default, if no @Priority is specified by the Converter , the converter is registered with a priority of 100 . Consider: package org.acme.config ; import jakarta.annotation.Priority ; import org.eclipse.microprofile.config.spi.Converter ; @Priority ( 150 ) public class SecretConverter implements Converter < CustomValue > { @Override public CustomValue convert ( String value ) { final int secretNumber ; if ( value . startsFrom ( \"OBF:\" )) { secretNumber = Integer . parseInt ( SecretDecoder . decode ( value )); } else { secretNumber = Integer . parseInt ( value ); } return new CustomValue ( secretNumber ); } } Two Converter s, ( CustomValueConverter and SecretConverter ) can convert the same type CustomValue . Since SecretConverter has a priority of 150 , it will be used instead of a CustomValueConverter which has a default priority of 100 (no annotation).","title":"Custom Converter"},{"location":"extensions/config-events/","text":"Config Events # The Config Events extension allows you to fire change events on Config Sources. Usage # To use the Config Events, add the following to your Maven pom.xml : <dependency> <groupId> io.smallrye.config </groupId> <artifactId> smallrye-config-events </artifactId> <version> 3.9.1-SNAPSHOT </version> </dependency> Events # The CDI Event is a ChangeEvent and contains the following fields: String key Optional\\ oldValue String newValue Type type String fromSource The ChangeEvent can be of any of the following types: NEW - When you create a new key and value (i.e. the key does not exist anywhere in any config source) UPDATE - When you update a value of an existing key (i.e. the key and value exist somewhere in a config source) REMOVE - When you remove the value from the source (and that changed the overall config) Observing Events # You can listen to all or some of these events, filtering by type and/or key and/or source , example: // Getting all config event public void all ( @Observes ChangeEvent changeEvent ){ log . log ( Level . SEVERE , \"ALL: Received a config change event: {0}\" , changeEvent ); } // Get only new values public void newValue ( @Observes @TypeFilter ( Type . NEW ) ChangeEvent changeEvent ){ log . log ( Level . SEVERE , \"NEW: Received a config change event: {0}\" , changeEvent ); } // Get only override values public void overrideValue ( @Observes @TypeFilter ( Type . UPDATE ) ChangeEvent changeEvent ){ log . log ( Level . SEVERE , \"UPDATE: Received a config change event: {0}\" , changeEvent ); } // Get only revert values public void revertValue ( @Observes @TypeFilter ( Type . REMOVE ) ChangeEvent changeEvent ){ log . log ( Level . SEVERE , \"REMOVE: Received a config change event: {0}\" , changeEvent ); } // Getting all config event when key is some.key public void allForKey ( @Observes @KeyFilter ( \"some.key\" ) ChangeEvent changeEvent ){ log . log ( Level . SEVERE , \"ALL for key [some.key]: Received a config change event: {0}\" , changeEvent ); } // Getting all config event when key is some.key for new events public void newForKey ( @Observes @TypeFilter ( Type . NEW ) @KeyFilter ( \"some.key\" ) ChangeEvent changeEvent ){ log . log ( Level . SEVERE , \"NEW for key [some.key]: Received a config change event: {0}\" , changeEvent ); } // Getting all config event when key is some.key for override events public void overrideForKey ( @Observes @TypeFilter ( Type . UPDATE ) @KeyFilter ( \"some.key\" ) ChangeEvent changeEvent ){ log . log ( Level . SEVERE , \"UPDATE for key [some.key]: Received a config change event: {0}\" , changeEvent ); } // Getting all config event when key is some.key for revert events public void revertForKey ( @Observes @TypeFilter ( Type . REMOVE ) @KeyFilter ( \"some.key\" ) ChangeEvent changeEvent ){ log . log ( Level . SEVERE , \"REMOVE for key [some.key]: Received a config change event: {0}\" , changeEvent ); } // Getting all config events for a certain source public void allForSource ( @Observes @SourceFilter ( \"MemoryConfigSource\" ) ChangeEvent changeEvent ){ log . log ( Level . SEVERE , \"ALL for source [MemoryConfigSource]: Received a config change event: {0}\" , changeEvent ); } // Getting all config events for a certain source public void allForSourceAndKey ( @Observes @SourceFilter ( \"MemoryConfigSource\" ) @KeyFilter ( \"some.key\" ) ChangeEvent changeEvent ){ log . log ( Level . SEVERE , \"ALL for source [MemoryConfigSource] and for key [some.key]: Received a config change event: {0}\" , changeEvent ); } // Getting all config events for a certain source public void overrideForSourceAndKey ( @Observes @TypeFilter ( Type . UPDATE ) @SourceFilter ( \"MemoryConfigSource\" ) @KeyFilter ( \"some.key\" ) ChangeEvent changeEvent ){ log . log ( Level . SEVERE , \"UPDATE for source [MemoryConfigSource] and for key [some.key]: Received a config change event: {0}\" , changeEvent ); } Note: You can filter by including the @TypeFilter and/or the @KeyFilter and/or the @SourceFilter . Pattern matching on field. # You might want to listen for fields that match a certain regex. Example, listen to all keys that starts with some. : @RegexFilter ( \"^some\\\\..+\" ) public void allForPatternMatchOnKey ( @Observes ChangeEvent changeEvent ){ log . log ( Level . SEVERE , \"Pattern match on key: Received a config change event: {0}\" , changeEvent ); } By default, it will match on key , however you also listen on another field, for example, listen to all oldValue that starts with some. : @RegexFilter ( onField = Field . oldValue , value = \"^some\\\\..+\" ) public void allForPatternMatchOnOldValue ( @Observes ChangeEvent changeEvent ){ log . log ( Level . SEVERE , \"Pattern match on old value: Received a config change event: {0}\" , changeEvent ); } You can Match on the following fields of the ChangeEvent object: key oldValue newValue fromSource Implementing Events in a ConfigSource # The ChangeEventNotifier allows you to detect changes and fire the appropriate events. To use it in your own source: Get a snapshot of the properties before the change. Get a snapshot of the properties after the change. Call detectChangesAndFire method: Example: Map < String , String > before = new HashMap <> ( configSource . getProperties ()); memoryConfigSource . getProperties (). remove ( key ); Map < String , String > after = new HashMap <> ( configSource . getProperties ()); ChangeEventNotifier . getInstance (). detectChangesAndFire ( before , after , configSource . getName ()); or if you know the change and do not need detection: configSource . getProperties (). remove ( key ); ChangeEventNotifier . getInstance (). fire ( new ChangeEvent ( Type . REMOVE , key , getOptionalOldValue ( oldValue ), null , configSource . getName ()));","title":"Config Events"},{"location":"extensions/config-events/#config-events","text":"The Config Events extension allows you to fire change events on Config Sources.","title":"Config Events"},{"location":"extensions/config-events/#usage","text":"To use the Config Events, add the following to your Maven pom.xml : <dependency> <groupId> io.smallrye.config </groupId> <artifactId> smallrye-config-events </artifactId> <version> 3.9.1-SNAPSHOT </version> </dependency>","title":"Usage"},{"location":"extensions/config-events/#events","text":"The CDI Event is a ChangeEvent and contains the following fields: String key Optional\\ oldValue String newValue Type type String fromSource The ChangeEvent can be of any of the following types: NEW - When you create a new key and value (i.e. the key does not exist anywhere in any config source) UPDATE - When you update a value of an existing key (i.e. the key and value exist somewhere in a config source) REMOVE - When you remove the value from the source (and that changed the overall config)","title":"Events"},{"location":"extensions/config-events/#observing-events","text":"You can listen to all or some of these events, filtering by type and/or key and/or source , example: // Getting all config event public void all ( @Observes ChangeEvent changeEvent ){ log . log ( Level . SEVERE , \"ALL: Received a config change event: {0}\" , changeEvent ); } // Get only new values public void newValue ( @Observes @TypeFilter ( Type . NEW ) ChangeEvent changeEvent ){ log . log ( Level . SEVERE , \"NEW: Received a config change event: {0}\" , changeEvent ); } // Get only override values public void overrideValue ( @Observes @TypeFilter ( Type . UPDATE ) ChangeEvent changeEvent ){ log . log ( Level . SEVERE , \"UPDATE: Received a config change event: {0}\" , changeEvent ); } // Get only revert values public void revertValue ( @Observes @TypeFilter ( Type . REMOVE ) ChangeEvent changeEvent ){ log . log ( Level . SEVERE , \"REMOVE: Received a config change event: {0}\" , changeEvent ); } // Getting all config event when key is some.key public void allForKey ( @Observes @KeyFilter ( \"some.key\" ) ChangeEvent changeEvent ){ log . log ( Level . SEVERE , \"ALL for key [some.key]: Received a config change event: {0}\" , changeEvent ); } // Getting all config event when key is some.key for new events public void newForKey ( @Observes @TypeFilter ( Type . NEW ) @KeyFilter ( \"some.key\" ) ChangeEvent changeEvent ){ log . log ( Level . SEVERE , \"NEW for key [some.key]: Received a config change event: {0}\" , changeEvent ); } // Getting all config event when key is some.key for override events public void overrideForKey ( @Observes @TypeFilter ( Type . UPDATE ) @KeyFilter ( \"some.key\" ) ChangeEvent changeEvent ){ log . log ( Level . SEVERE , \"UPDATE for key [some.key]: Received a config change event: {0}\" , changeEvent ); } // Getting all config event when key is some.key for revert events public void revertForKey ( @Observes @TypeFilter ( Type . REMOVE ) @KeyFilter ( \"some.key\" ) ChangeEvent changeEvent ){ log . log ( Level . SEVERE , \"REMOVE for key [some.key]: Received a config change event: {0}\" , changeEvent ); } // Getting all config events for a certain source public void allForSource ( @Observes @SourceFilter ( \"MemoryConfigSource\" ) ChangeEvent changeEvent ){ log . log ( Level . SEVERE , \"ALL for source [MemoryConfigSource]: Received a config change event: {0}\" , changeEvent ); } // Getting all config events for a certain source public void allForSourceAndKey ( @Observes @SourceFilter ( \"MemoryConfigSource\" ) @KeyFilter ( \"some.key\" ) ChangeEvent changeEvent ){ log . log ( Level . SEVERE , \"ALL for source [MemoryConfigSource] and for key [some.key]: Received a config change event: {0}\" , changeEvent ); } // Getting all config events for a certain source public void overrideForSourceAndKey ( @Observes @TypeFilter ( Type . UPDATE ) @SourceFilter ( \"MemoryConfigSource\" ) @KeyFilter ( \"some.key\" ) ChangeEvent changeEvent ){ log . log ( Level . SEVERE , \"UPDATE for source [MemoryConfigSource] and for key [some.key]: Received a config change event: {0}\" , changeEvent ); } Note: You can filter by including the @TypeFilter and/or the @KeyFilter and/or the @SourceFilter .","title":"Observing Events"},{"location":"extensions/config-events/#pattern-matching-on-field","text":"You might want to listen for fields that match a certain regex. Example, listen to all keys that starts with some. : @RegexFilter ( \"^some\\\\..+\" ) public void allForPatternMatchOnKey ( @Observes ChangeEvent changeEvent ){ log . log ( Level . SEVERE , \"Pattern match on key: Received a config change event: {0}\" , changeEvent ); } By default, it will match on key , however you also listen on another field, for example, listen to all oldValue that starts with some. : @RegexFilter ( onField = Field . oldValue , value = \"^some\\\\..+\" ) public void allForPatternMatchOnOldValue ( @Observes ChangeEvent changeEvent ){ log . log ( Level . SEVERE , \"Pattern match on old value: Received a config change event: {0}\" , changeEvent ); } You can Match on the following fields of the ChangeEvent object: key oldValue newValue fromSource","title":"Pattern matching on field."},{"location":"extensions/config-events/#implementing-events-in-a-configsource","text":"The ChangeEventNotifier allows you to detect changes and fire the appropriate events. To use it in your own source: Get a snapshot of the properties before the change. Get a snapshot of the properties after the change. Call detectChangesAndFire method: Example: Map < String , String > before = new HashMap <> ( configSource . getProperties ()); memoryConfigSource . getProperties (). remove ( key ); Map < String , String > after = new HashMap <> ( configSource . getProperties ()); ChangeEventNotifier . getInstance (). detectChangesAndFire ( before , after , configSource . getName ()); or if you know the change and do not need detection: configSource . getProperties (). remove ( key ); ChangeEventNotifier . getInstance (). fire ( new ChangeEvent ( Type . REMOVE , key , getOptionalOldValue ( oldValue ), null , configSource . getName ()));","title":"Implementing Events in a ConfigSource"},{"location":"extensions/config-source-injection/","text":"Config Source Injection # The Config Source Injection extension allows you to use CDI injection to inject a ConfigSource by name in your CDI aware beans, or by looking it up programatically in the CDI BeanManager . Usage # To use the Config Source Injection, add the following to your Maven pom.xml : <dependency> <groupId> io.smallrye.config </groupId> <artifactId> smallrye-config-source-injection </artifactId> <version> 3.9.1-SNAPSHOT </version> </dependency> Injecting Sources # You can inject a ConfigSource by referencing it by name: @Inject @Name ( \"MemoryConfigSource\" ) private ConfigSource memoryConfigSource ; @Inject @Name ( \"SysPropConfigSource\" ) private ConfigSource systemPropertiesConfigSource ; You can also get a Map of all config sources. The map key holds the ConfigSource name and the map value the ConfigSource : @Inject @ConfigSourceMap private Map < String , ConfigSource > configSourceMap ;","title":"Config Source Injection"},{"location":"extensions/config-source-injection/#config-source-injection","text":"The Config Source Injection extension allows you to use CDI injection to inject a ConfigSource by name in your CDI aware beans, or by looking it up programatically in the CDI BeanManager .","title":"Config Source Injection"},{"location":"extensions/config-source-injection/#usage","text":"To use the Config Source Injection, add the following to your Maven pom.xml : <dependency> <groupId> io.smallrye.config </groupId> <artifactId> smallrye-config-source-injection </artifactId> <version> 3.9.1-SNAPSHOT </version> </dependency>","title":"Usage"},{"location":"extensions/config-source-injection/#injecting-sources","text":"You can inject a ConfigSource by referencing it by name: @Inject @Name ( \"MemoryConfigSource\" ) private ConfigSource memoryConfigSource ; @Inject @Name ( \"SysPropConfigSource\" ) private ConfigSource systemPropertiesConfigSource ; You can also get a Map of all config sources. The map key holds the ConfigSource name and the map value the ConfigSource : @Inject @ConfigSourceMap private Map < String , ConfigSource > configSourceMap ;","title":"Injecting Sources"},{"location":"extensions/fallback/","text":"Fallback # The io.smallrye.config.FallbackConfigSourceInterceptor allows to fall back to another configuration name, by providing a transformation function or just a simple key value map. When a configuration name does not exist, there might be another configuration name that the config can fall back to provide the same expected behavior. The fallback function is only applied if the original resolved configuration name is not found and resolved to the fallback name. package org.acme.config ; import java.util.function.Function ; import io.smallrye.config.FallbackConfigSourceInterceptor ; public class MicroProfileConfigFallbackInterceptor extends FallbackConfigSourceInterceptor { public MicroProfileConfigFallbackInterceptor ( final Function < String , String > mapping ) { super ( name -> name . startsWith ( \"mp.config\" ) ? name . replaceAll ( \"mp\\\\.config\" , \"smallrye.config\" ) : name ); } } And registration in: META-INF/services/io.smallrye.config.ConfigSourceInterceptor org.acme.config.MicroProfileConfigFallbackInterceptor The MicroProfileConfigFallbackInterceptor can fallback configuration names in the mp.config namespace to the smallrye.config namespace. Example application.properties mp.config.profile = test smallrye.config.profile = prod A lookup to mp.config.profile returns the value test . application.properties smallrye.config.profile = prod A lookup to mp.config.profile returns the value prod . The config is not able to find a value for mp.config.profile , so the interceptor fallbacks and lookups the value of smallrye.config.profile .","title":"Fallback"},{"location":"extensions/fallback/#fallback","text":"The io.smallrye.config.FallbackConfigSourceInterceptor allows to fall back to another configuration name, by providing a transformation function or just a simple key value map. When a configuration name does not exist, there might be another configuration name that the config can fall back to provide the same expected behavior. The fallback function is only applied if the original resolved configuration name is not found and resolved to the fallback name. package org.acme.config ; import java.util.function.Function ; import io.smallrye.config.FallbackConfigSourceInterceptor ; public class MicroProfileConfigFallbackInterceptor extends FallbackConfigSourceInterceptor { public MicroProfileConfigFallbackInterceptor ( final Function < String , String > mapping ) { super ( name -> name . startsWith ( \"mp.config\" ) ? name . replaceAll ( \"mp\\\\.config\" , \"smallrye.config\" ) : name ); } } And registration in: META-INF/services/io.smallrye.config.ConfigSourceInterceptor org.acme.config.MicroProfileConfigFallbackInterceptor The MicroProfileConfigFallbackInterceptor can fallback configuration names in the mp.config namespace to the smallrye.config namespace. Example application.properties mp.config.profile = test smallrye.config.profile = prod A lookup to mp.config.profile returns the value test . application.properties smallrye.config.profile = prod A lookup to mp.config.profile returns the value prod . The config is not able to find a value for mp.config.profile , so the interceptor fallbacks and lookups the value of smallrye.config.profile .","title":"Fallback"},{"location":"extensions/interceptors/","text":"Interceptors # SmallRye Config provides an interceptor chain that hooks into the configuration values resolution. This is useful to implement features like Profiles , Property Expressions , or just logging to find out where the config value was loaded from. An interceptor can be created by implementing the ConfigSourceInterceptor interface. An interceptor requires an implementation of io.smallrye.config.ConfigSourceInterceptor . Each implementation requires registration via the ServiceLoader mechanism in the META-INF/services/io.smallrye.config.ConfigSourceInterceptor file. Alternatively, interceptors may be registered via the Programmatic API in SmallRyeConfigBuilder#withInterceptors . The io.smallrye.config.ConfigSourceInterceptor is able to intercept the resolution of a configuration name with the method ConfigValue getValue(ConfigSourceInterceptorContext context, String name) . The ConfigSourceInterceptorContext is used to proceed with the interceptor chain. The chain can be short-circuited by returning an instance of io.smallrye.config.ConfigValue . The ConfigValue objects hold information about the key name, value, config source origin and ordinal. Info The interceptor chain is applied before any conversion is performed on the configuration value. package org.acme.config ; import static io.smallrye.config.SecretKeys.doLocked ; import jakarta.annotation.Priority ; import io.smallrye.config.ConfigSourceInterceptor ; import io.smallrye.config._private.ConfigLogging ; @Priority ( Priorities . LIBRARY + 200 ) public class LoggingConfigSourceInterceptor implements ConfigSourceInterceptor { private static final long serialVersionUID = 367246512037404779L ; @Override public ConfigValue getValue ( final ConfigSourceInterceptorContext context , final String name ) { ConfigValue configValue = doLocked (() -> context . proceed ( name )); if ( configValue != null ) { ConfigLogging . log . lookup ( configValue . getName (), configValue . getLocation (), configValue . getValue ()); } else { ConfigLogging . log . notFound ( name ); } return configValue ; } } And registration in: META-INF/services/io.smallrye.config.ConfigSourceInterceptor org.acme.config.LoggingConfigSourceInterceptor The LoggingConfigSourceInterceptor logs looks up configuration names in the provided logging platform. The log information includes config name and value, the config source origin and location if exists. Interceptors may also be created with an implementation of io.smallrye.config.ConfigSourceInterceptorFactory . Each implementation requires registration via the ServiceLoader mechanism in the META-INF/services/io.smallrye.config.ConfigSourceInterceptorFactory file. Alternatively, interceptors factories may be registered via the Programmatic API in SmallRyeConfigBuilder#withInterceptorFactories . The ConfigSourceInterceptorFactory can initialize an interceptor with access to the current chain (so it can be used to configure the interceptor and retrieve configuration values) and set the priority. A ConfigSourceInterceptor implementation class can specify a priority by way of the standard jakarta.annotation.Priority annotation. If no priority is explicitly assigned, the default priority value of io.smallrye.config.Priorities.APPLICATION is assumed. If multiple interceptors are registered with the same priority, then their execution order may be non-deterministic. A collection of built-in priority constants can be found in io.smallrye.config.Priorities . It is recommended to use io.smallrye.config.Priorities.APPLICATION as a baseline for user defined interceptors.","title":"Interceptors"},{"location":"extensions/interceptors/#interceptors","text":"SmallRye Config provides an interceptor chain that hooks into the configuration values resolution. This is useful to implement features like Profiles , Property Expressions , or just logging to find out where the config value was loaded from. An interceptor can be created by implementing the ConfigSourceInterceptor interface. An interceptor requires an implementation of io.smallrye.config.ConfigSourceInterceptor . Each implementation requires registration via the ServiceLoader mechanism in the META-INF/services/io.smallrye.config.ConfigSourceInterceptor file. Alternatively, interceptors may be registered via the Programmatic API in SmallRyeConfigBuilder#withInterceptors . The io.smallrye.config.ConfigSourceInterceptor is able to intercept the resolution of a configuration name with the method ConfigValue getValue(ConfigSourceInterceptorContext context, String name) . The ConfigSourceInterceptorContext is used to proceed with the interceptor chain. The chain can be short-circuited by returning an instance of io.smallrye.config.ConfigValue . The ConfigValue objects hold information about the key name, value, config source origin and ordinal. Info The interceptor chain is applied before any conversion is performed on the configuration value. package org.acme.config ; import static io.smallrye.config.SecretKeys.doLocked ; import jakarta.annotation.Priority ; import io.smallrye.config.ConfigSourceInterceptor ; import io.smallrye.config._private.ConfigLogging ; @Priority ( Priorities . LIBRARY + 200 ) public class LoggingConfigSourceInterceptor implements ConfigSourceInterceptor { private static final long serialVersionUID = 367246512037404779L ; @Override public ConfigValue getValue ( final ConfigSourceInterceptorContext context , final String name ) { ConfigValue configValue = doLocked (() -> context . proceed ( name )); if ( configValue != null ) { ConfigLogging . log . lookup ( configValue . getName (), configValue . getLocation (), configValue . getValue ()); } else { ConfigLogging . log . notFound ( name ); } return configValue ; } } And registration in: META-INF/services/io.smallrye.config.ConfigSourceInterceptor org.acme.config.LoggingConfigSourceInterceptor The LoggingConfigSourceInterceptor logs looks up configuration names in the provided logging platform. The log information includes config name and value, the config source origin and location if exists. Interceptors may also be created with an implementation of io.smallrye.config.ConfigSourceInterceptorFactory . Each implementation requires registration via the ServiceLoader mechanism in the META-INF/services/io.smallrye.config.ConfigSourceInterceptorFactory file. Alternatively, interceptors factories may be registered via the Programmatic API in SmallRyeConfigBuilder#withInterceptorFactories . The ConfigSourceInterceptorFactory can initialize an interceptor with access to the current chain (so it can be used to configure the interceptor and retrieve configuration values) and set the priority. A ConfigSourceInterceptor implementation class can specify a priority by way of the standard jakarta.annotation.Priority annotation. If no priority is explicitly assigned, the default priority value of io.smallrye.config.Priorities.APPLICATION is assumed. If multiple interceptors are registered with the same priority, then their execution order may be non-deterministic. A collection of built-in priority constants can be found in io.smallrye.config.Priorities . It is recommended to use io.smallrye.config.Priorities.APPLICATION as a baseline for user defined interceptors.","title":"Interceptors"},{"location":"extensions/logging/","text":"LoggingConfigSourceInterceptor # The io.smallrye.config.LoggingConfigSourceInterceptor logs lookups of configuration names in the provided logging platform. The log information includes config name and value, the config source origin and location if it exists. The log is done as debug , so the debug threshold must be set to debug for the io.smallrye.config appender to display the logs. This requires registration via the ServiceLoader mechanism in the META-INF/services/io.smallrye.config.ConfigSourceInterceptorFactory file of the io.smallrye.config.LoggingConfigSourceInterceptor interceptor.","title":"Logging"},{"location":"extensions/logging/#loggingconfigsourceinterceptor","text":"The io.smallrye.config.LoggingConfigSourceInterceptor logs lookups of configuration names in the provided logging platform. The log information includes config name and value, the config source origin and location if it exists. The log is done as debug , so the debug threshold must be set to debug for the io.smallrye.config appender to display the logs. This requires registration via the ServiceLoader mechanism in the META-INF/services/io.smallrye.config.ConfigSourceInterceptorFactory file of the io.smallrye.config.LoggingConfigSourceInterceptor interceptor.","title":"LoggingConfigSourceInterceptor"},{"location":"extensions/relocate/","text":"Relocate # The io.smallrye.config.RelocateConfigSourceInterceptor allows to relocate a configuration name to another name, by providing a transformation function or just a simple key value map. When a configuration key is renamed, lookup needs to happen on the new name, but also on the old name if the config sources are not updated yet. The relocation function gives priority to the new resolved configuration name or resolves to the old name if no value is found under the new relocation name. package org.acme.config ; import java.util.function.Function ; import io.smallrye.config.RelocateConfigSourceInterceptor ; public class MicroProfileConfigRelocateInterceptor extends RelocateConfigSourceInterceptor { public MicroProfileConfigRelocateInterceptor ( final Function < String , String > mapping ) { super ( name -> name . startsWith ( \"mp.config\" ) ? name . replaceAll ( \"mp\\\\.config\" , \"smallrye.config\" ) : name ); } } And registration in: META-INF/services/io.smallrye.config.ConfigSourceInterceptor org.acme.config.MicroProfileConfigRelocateInterceptor The MicroProfileConfigRelocateInterceptor can relocate configuration names in the mp.config namespace to the smallrye.config namespace. Example application.properties mp.config.profile = test smallrye.config.profile = prod A lookup to mp.config.profile returns the value prod . The config finds a valid value in the relocated name smallrye.config.profile , so the interceptor will use this value instead of the one in mp.config.profile .","title":"Relocate"},{"location":"extensions/relocate/#relocate","text":"The io.smallrye.config.RelocateConfigSourceInterceptor allows to relocate a configuration name to another name, by providing a transformation function or just a simple key value map. When a configuration key is renamed, lookup needs to happen on the new name, but also on the old name if the config sources are not updated yet. The relocation function gives priority to the new resolved configuration name or resolves to the old name if no value is found under the new relocation name. package org.acme.config ; import java.util.function.Function ; import io.smallrye.config.RelocateConfigSourceInterceptor ; public class MicroProfileConfigRelocateInterceptor extends RelocateConfigSourceInterceptor { public MicroProfileConfigRelocateInterceptor ( final Function < String , String > mapping ) { super ( name -> name . startsWith ( \"mp.config\" ) ? name . replaceAll ( \"mp\\\\.config\" , \"smallrye.config\" ) : name ); } } And registration in: META-INF/services/io.smallrye.config.ConfigSourceInterceptor org.acme.config.MicroProfileConfigRelocateInterceptor The MicroProfileConfigRelocateInterceptor can relocate configuration names in the mp.config namespace to the smallrye.config namespace. Example application.properties mp.config.profile = test smallrye.config.profile = prod A lookup to mp.config.profile returns the value prod . The config finds a valid value in the relocated name smallrye.config.profile , so the interceptor will use this value instead of the one in mp.config.profile .","title":"Relocate"}]}